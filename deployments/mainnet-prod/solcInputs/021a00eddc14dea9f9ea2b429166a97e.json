{
  "language": "Solidity",
  "sources": {
    "contracts/crytic/interfaces.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ncontract CryticInterface {\n    address internal crytic_owner =\n        address(0x627306090abaB3A6e1400e9345bC60c78a8BEf57);\n    address internal crytic_user =\n        address(0xf17f52151EbEF6C7334FAD080c5704D77216b732);\n    address internal crytic_attacker =\n        address(0xC5fdf4076b8F3A5357c5E395ab970B5B54098Fef);\n    uint256 internal initialTotalSupply;\n    uint256 internal initialBalance_owner;\n    uint256 internal initialBalance_user;\n    uint256 internal initialBalance_attacker;\n}\n"
    },
    "contracts/crytic/PropertiesXUSDTransferable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./interfaces.sol\";\nimport \"../token/XUSD.sol\";\n\ncontract PropertiesXUSDTransferable is CryticInterface, XUSD {\n    function init_total_supply() public view returns (bool) {\n        return\n            this.totalSupply() >= 0 && this.totalSupply() == initialTotalSupply;\n    }\n\n    function init_owner_balance() public view returns (bool) {\n        return initialBalance_owner == this.balanceOf(crytic_owner);\n    }\n\n    function init_user_balance() public view returns (bool) {\n        return initialBalance_user == this.balanceOf(crytic_user);\n    }\n\n    function init_attacker_balance() public view returns (bool) {\n        return initialBalance_attacker == this.balanceOf(crytic_attacker);\n    }\n\n    function init_caller_balance() public view returns (bool) {\n        return this.balanceOf(msg.sender) > 0;\n    }\n\n    function init_total_supply_is_balances() public view returns (bool) {\n        return\n            this.balanceOf(crytic_owner) +\n                this.balanceOf(crytic_user) +\n                this.balanceOf(crytic_attacker) ==\n            this.totalSupply();\n    }\n\n    function crytic_zero_always_empty_ERC20Properties()\n        public\n        view\n        returns (bool)\n    {\n        return this.balanceOf(address(0x0)) == 0;\n    }\n\n    function crytic_approve_overwrites() public returns (bool) {\n        bool approve_return;\n        approve_return = approve(crytic_user, 10);\n        require(approve_return);\n        approve_return = approve(crytic_user, 20);\n        require(approve_return);\n        return this.allowance(msg.sender, crytic_user) == 20;\n    }\n\n    function crytic_less_than_total_ERC20Properties()\n        public\n        view\n        returns (bool)\n    {\n        return this.balanceOf(msg.sender) <= totalSupply();\n    }\n\n    function crytic_revert_transfer_to_zero_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        if (this.balanceOf(msg.sender) == 0) {\n            revert();\n        }\n        return transfer(address(0x0), this.balanceOf(msg.sender));\n    }\n\n    function crytic_revert_transferFrom_to_zero_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        if (balance == 0) {\n            revert();\n        }\n        approve(msg.sender, balance);\n        return\n            transferFrom(msg.sender, address(0x0), this.balanceOf(msg.sender));\n    }\n\n    function crytic_self_transferFrom_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        bool approve_return = approve(msg.sender, balance);\n        bool transfer_return = transferFrom(msg.sender, msg.sender, balance);\n        return\n            (this.balanceOf(msg.sender) == balance) &&\n            approve_return &&\n            transfer_return;\n    }\n\n    function crytic_self_transferFrom_to_other_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        bool approve_return = approve(msg.sender, balance);\n        address other = crytic_user;\n        if (other == msg.sender) {\n            other = crytic_owner;\n        }\n        bool transfer_return = transferFrom(msg.sender, other, balance);\n        return\n            (this.balanceOf(msg.sender) == 0) &&\n            approve_return &&\n            transfer_return;\n    }\n\n    function crytic_self_transfer_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        bool transfer_return = transfer(msg.sender, balance);\n        return (this.balanceOf(msg.sender) == balance) && transfer_return;\n    }\n\n    function crytic_transfer_to_other_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        address other = crytic_user;\n        if (other == msg.sender) {\n            other = crytic_owner;\n        }\n        if (balance >= 1) {\n            bool transfer_other = transfer(other, 1);\n            return\n                (this.balanceOf(msg.sender) == balance - 1) &&\n                (this.balanceOf(other) >= 1) &&\n                transfer_other;\n        }\n        return true;\n    }\n\n    function crytic_revert_transfer_to_user_ERC20PropertiesTransferable()\n        public\n        returns (bool)\n    {\n        uint256 balance = this.balanceOf(msg.sender);\n        if (balance == (2**128 - 1)) return true;\n        bool transfer_other = transfer(crytic_user, balance + 1);\n        return transfer_other;\n    }\n}\n"
    },
    "contracts/token/XUSD.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Token Contract\n * @dev ERC20 compatible contract for XUSD\n * @dev Implements an elastic supply\n * @author Factor Finance\n */\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { InitializableERC20Detailed } from \"../utils/InitializableERC20Detailed.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * NOTE that this is an ERC20 token but the invariant that the sum of\n * balanceOf(x) for all x is not >= totalSupply(). This is a consequence of the\n * rebasing design. Any integrations with XUSD should be aware.\n */\n\ncontract XUSD is Initializable, InitializableERC20Detailed, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n\n    event TotalSupplyUpdated(\n        uint256 totalSupply,\n        uint256 rebasingCredits,\n        uint256 rebasingCreditsPerToken\n    );\n\n    enum RebaseOptions {\n        NotSet,\n        OptOut,\n        OptIn\n    }\n\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n    uint256 public _totalSupply;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address public vaultAddress = address(0);\n    mapping(address => uint256) private _creditBalances;\n    uint256 private _rebasingCredits;\n    uint256 private _rebasingCreditsPerToken;\n    // Frozen address/credits are non rebasing (value is held in contracts which\n    // do not receive yield unless they explicitly opt in)\n    uint256 public nonRebasingSupply;\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\n    mapping(address => RebaseOptions) public rebaseState;\n    mapping(address => uint256) public isUpgraded; // DEPRECATED\n\n    function initialize(\n        string calldata _nameArg,\n        string calldata _symbolArg,\n        address _vaultAddress\n    ) external onlyGovernor initializer {\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\n        _rebasingCreditsPerToken = 1e18;\n        vaultAddress = _vaultAddress;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault contract\n     */\n    modifier onlyVault() {\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @return The total supply of XUSD.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return rebasingCreditsPerToken\n     */\n    function rebasingCreditsPerToken() public view returns (uint256) {\n        return _rebasingCreditsPerToken;\n    }\n\n    /**\n     * @return Total number of rebasing credits\n     */\n    function rebasingCredits() public view returns (uint256) {\n        return _rebasingCredits;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _account Address to query the balance of.\n     * @return A uint256 representing the amount of base units owned by the\n     *         specified address.\n     */\n    function balanceOf(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_creditBalances[_account] == 0) return 0;\n        return\n            _creditBalances[_account].divPrecisely(_creditsPerToken(_account));\n    }\n\n    /**\n     * @dev Gets the credits balance of the specified address.\n     * @param _account The address to query the balance of.\n     * @return (uint256, uint256, bool) Credit balance, credits per token of the\n     *         address\n     */\n    function creditsBalanceOf(address _account)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (_creditBalances[_account], _creditsPerToken(_account));\n    }\n\n    /**\n     * @dev Transfer tokens to a specified address.\n     * @param _to the address to transfer to.\n     * @param _value the amount to be transferred.\n     * @return true on success.\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(\n            _value <= balanceOf(msg.sender),\n            \"Transfer greater than balance\"\n        );\n\n        _executeTransfer(msg.sender, _to, _value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_to != address(0), \"Transfer to zero address\");\n        require(_value <= balanceOf(_from), \"Transfer greater than balance\");\n\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\n            _value\n        );\n\n        _executeTransfer(_from, _to, _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Update the count of non rebasing credits in response to a transfer\n     * @param _from The address you want to send tokens from.\n     * @param _to The address you want to transfer to.\n     * @param _value Amount of XUSD to transfer\n     */\n    function _executeTransfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        bool isNonRebasingTo = _isNonRebasingAccount(_to);\n        bool isNonRebasingFrom = _isNonRebasingAccount(_from);\n\n        // Credits deducted and credited might be different due to the\n        // differing creditsPerToken used by each account\n        uint256 creditsCredited = _value.mulTruncate(_creditsPerToken(_to));\n        uint256 creditsDeducted = _value.mulTruncate(_creditsPerToken(_from));\n\n        _creditBalances[_from] = _creditBalances[_from].sub(\n            creditsDeducted,\n            \"Transfer amount exceeds balance\"\n        );\n        _creditBalances[_to] = _creditBalances[_to].add(creditsCredited);\n\n        if (isNonRebasingTo && !isNonRebasingFrom) {\n            // Transfer to non-rebasing account from rebasing account, credits\n            // are removed from the non rebasing tally\n            nonRebasingSupply = nonRebasingSupply.add(_value);\n            // Update rebasingCredits by subtracting the deducted amount\n            _rebasingCredits = _rebasingCredits.sub(creditsDeducted);\n        } else if (!isNonRebasingTo && isNonRebasingFrom) {\n            // Transfer to rebasing account from non-rebasing account\n            // Decreasing non-rebasing credits by the amount that was sent\n            nonRebasingSupply = nonRebasingSupply.sub(_value);\n            // Update rebasingCredits by adding the credited amount\n            _rebasingCredits = _rebasingCredits.add(creditsCredited);\n        }\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that _owner has allowed to\n     *      `_spender`.\n     * @param _owner The address which owns the funds.\n     * @param _spender The address which will spend the funds.\n     * @return The number of tokens still available for the _spender.\n     */\n    function allowance(address _owner, address _spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens\n     *      on behalf of msg.sender. This method is included for ERC20\n     *      compatibility. `increaseAllowance` and `decreaseAllowance` should be\n     *      used instead.\n     *\n     *      Changing an allowance with this method brings the risk that someone\n     *      may transfer both the old and the new allowance - if they are both\n     *      greater than zero - if a transfer transaction is mined before the\n     *      later approve() call is mined.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to\n     *      `_spender`.\n     *      This method should be used instead of approve() to avoid the double\n     *      approval vulnerability described above.\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        returns (bool)\n    {\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]\n            .add(_addedValue);\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to\n            `_spender`.\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance\n     *        by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        returns (bool)\n    {\n        uint256 oldValue = _allowances[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            _allowances[msg.sender][_spender] = 0;\n        } else {\n            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Mints new tokens, increasing totalSupply.\n     */\n    function mint(address _account, uint256 _amount) external onlyVault {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Mint to the zero address\");\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);\n\n        // If the account is non rebasing and doesn't have a set creditsPerToken\n        // then set it i.e. this is a mint from a fresh contract\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.add(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.add(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Burns tokens, decreasing totalSupply.\n     */\n    function burn(address account, uint256 amount) external onlyVault {\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must have at least `_amount` tokens.\n     */\n    function _burn(address _account, uint256 _amount) internal nonReentrant {\n        require(_account != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\n        uint256 currentCredits = _creditBalances[_account];\n\n        // Remove the credits, burning rounding errors\n        if (\n            currentCredits == creditAmount || currentCredits - 1 == creditAmount\n        ) {\n            // Handle dust from rounding\n            _creditBalances[_account] = 0;\n        } else if (currentCredits > creditAmount) {\n            _creditBalances[_account] = _creditBalances[_account].sub(\n                creditAmount\n            );\n        } else {\n            revert(\"Remove exceeds balance\");\n        }\n\n        // Remove from the credit tallies and non-rebasing supply\n        if (isNonRebasingAccount) {\n            nonRebasingSupply = nonRebasingSupply.sub(_amount);\n        } else {\n            _rebasingCredits = _rebasingCredits.sub(creditAmount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Get the credits per token for an account. Returns a fixed amount\n     *      if the account is non-rebasing.\n     * @param _account Address of the account.\n     */\n    function _creditsPerToken(address _account)\n        internal\n        view\n        returns (uint256)\n    {\n        if (nonRebasingCreditsPerToken[_account] != 0) {\n            return nonRebasingCreditsPerToken[_account];\n        } else {\n            return _rebasingCreditsPerToken;\n        }\n    }\n\n    /**\n     * @dev Is an account using rebasing accounting or non-rebasing accounting?\n     *      Also, ensure contracts are non-rebasing if they have not opted in.\n     * @param _account Address of the account.\n     */\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\n        bool isContract = Address.isContract(_account);\n        if (isContract && rebaseState[_account] == RebaseOptions.NotSet) {\n            _ensureRebasingMigration(_account);\n        }\n        return nonRebasingCreditsPerToken[_account] > 0;\n    }\n\n    /**\n     * @dev Ensures internal account for rebasing and non-rebasing credits and\n     *      supply is updated following deployment of frozen yield change.\n     */\n    function _ensureRebasingMigration(address _account) internal {\n        if (nonRebasingCreditsPerToken[_account] == 0) {\n            if (_creditBalances[_account] == 0) {\n                // Since there is no existing balance, we can directly set to\n                // high resolution, and do not have to do any other bookkeeping\n                nonRebasingCreditsPerToken[_account] = 1e27;\n            } else {\n                // Migrate an existing account:\n\n                // Set fixed credits per token for this account\n                nonRebasingCreditsPerToken[_account] = _rebasingCreditsPerToken;\n                // Update non rebasing supply\n                nonRebasingSupply = nonRebasingSupply.add(balanceOf(_account));\n                // Update credit tallies\n                _rebasingCredits = _rebasingCredits.sub(\n                    _creditBalances[_account]\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Add a contract address to the non-rebasing exception list. The\n     * address's balance will be part of rebases and the account will be exposed\n     * to upside and downside.\n     */\n    function rebaseOptIn() public nonReentrant {\n        require(_isNonRebasingAccount(msg.sender), \"Account has not opted out\");\n\n        // Convert balance into the same amount at the current exchange rate\n        uint256 newCreditBalance = _creditBalances[msg.sender]\n            .mul(_rebasingCreditsPerToken)\n            .div(_creditsPerToken(msg.sender));\n\n        // Decreasing non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));\n\n        _creditBalances[msg.sender] = newCreditBalance;\n\n        // Increase rebasing credits, totalSupply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.add(_creditBalances[msg.sender]);\n\n        rebaseState[msg.sender] = RebaseOptions.OptIn;\n\n        // Delete any fixed credits per token\n        delete nonRebasingCreditsPerToken[msg.sender];\n    }\n\n    /**\n     * @dev Explicitly mark that an address is non-rebasing.\n     */\n    function rebaseOptOut() public nonReentrant {\n        require(!_isNonRebasingAccount(msg.sender), \"Account has not opted in\");\n\n        // Increase non rebasing supply\n        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));\n        // Set fixed credits per token\n        nonRebasingCreditsPerToken[msg.sender] = _rebasingCreditsPerToken;\n\n        // Decrease rebasing credits, total supply remains unchanged so no\n        // adjustment necessary\n        _rebasingCredits = _rebasingCredits.sub(_creditBalances[msg.sender]);\n\n        // Mark explicitly opted out of rebasing\n        rebaseState[msg.sender] = RebaseOptions.OptOut;\n    }\n\n    /**\n     * @dev Modify the supply without minting new tokens. This uses a change in\n     *      the exchange rate between \"credits\" and XUSD tokens to change balances.\n     * @param _newTotalSupply New total supply of XUSD.\n     */\n    function changeSupply(uint256 _newTotalSupply)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_totalSupply > 0, \"Cannot increase 0 supply\");\n\n        if (_totalSupply == _newTotalSupply) {\n            emit TotalSupplyUpdated(\n                _totalSupply,\n                _rebasingCredits,\n                _rebasingCreditsPerToken\n            );\n            return;\n        }\n\n        _totalSupply = _newTotalSupply > MAX_SUPPLY\n            ? MAX_SUPPLY\n            : _newTotalSupply;\n\n        _rebasingCreditsPerToken = _rebasingCredits.divPrecisely(\n            _totalSupply.sub(nonRebasingSupply)\n        );\n\n        require(_rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n        _totalSupply = _rebasingCredits\n            .divPrecisely(_rebasingCreditsPerToken)\n            .add(nonRebasingSupply);\n\n        emit TotalSupplyUpdated(\n            _totalSupply,\n            _rebasingCredits,\n            _rebasingCreditsPerToken\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            initializing || !initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/utils/InitializableERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\n */\nabstract contract InitializableERC20Detailed is IERC20 {\n    // Storage gap to skip storage from prior to XUSD reset\n    uint256[100] private _____gap;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\n     */\n    function _initialize(\n        string memory nameArg,\n        string memory symbolArg,\n        uint8 decimalsArg\n    ) internal {\n        _name = nameArg;\n        _symbol = symbolArg;\n        _decimals = decimalsArg;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/utils/StableMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// Based on StableMath from Stability Labs Pty. Ltd.\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /***************************************\n                    Helpers\n    ****************************************/\n\n    /**\n     * @dev Adjust the scale of an integer\n     * @param to Decimals to scale to\n     * @param from Decimals to scale from\n     */\n    function scaleBy(\n        uint256 x,\n        uint256 to,\n        uint256 from\n    ) internal pure returns (uint256) {\n        if (to > from) {\n            x = x.mul(10**(to - from));\n        } else if (to < from) {\n            x = x.div(10**(from - to));\n        }\n        return x;\n    }\n\n    /***************************************\n               Precise Arithmetic\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @param scale Scale unit\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *         scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        uint256 z = x.mul(y);\n        // return 9e36 / 1e18 = 9e18\n        return z.div(scale);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x Left hand input to multiplication\n     * @param y Right hand input to multiplication\n     * @return Result after multiplying the two inputs and then dividing by the shared\n     *          scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x.mul(y);\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil.div(FULL_SCALE);\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x Left hand input to division\n     * @param y Right hand input to division\n     * @return Result after multiplying the left operand by the scale, and\n     *         executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256)\n    {\n        // e.g. 8e18 * 1e18 = 8e36\n        uint256 z = x.mul(FULL_SCALE);\n        // e.g. 8e36 / 10e18 = 8e17\n        return z.div(y);\n    }\n}\n"
    },
    "contracts/governance/Governable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Governable Contract\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Factor Finance\n */\ncontract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"XUSD.governor\");\n    bytes32 private constant governorPosition =\n        0xfe7bb572d5723516ce4fe7a6a664f5adb38f5714efcd271411ed70a34d3ef2f7;\n\n    // keccak256(\"XUSD.pending.governor\");\n    bytes32 private constant pendingGovernorPosition =\n        0x1973cae3d8695cb4c31dce9679edb790944900898ecc70570ba365e7de143b0a;\n\n    // keccak256(\"XUSD.reentry.status\");\n    bytes32 private constant reentryStatusPosition =\n        0x218adab1852f0bdeacb3305483cf296dbcf6abf496f646284463c8e6a43fa665;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial Governor.\n     */\n    constructor() {\n        _setGovernor(msg.sender);\n        emit GovernorshipTransferred(address(0), _governor());\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        bytes32 position = governorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        emit GovernorshipTransferred(_governor(), _newGovernor);\n        _setGovernor(_newGovernor);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/crytic/TestXUSDTransferable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./PropertiesXUSDTransferable.sol\";\n\ncontract TestXUSDTransferable is PropertiesXUSDTransferable {\n    constructor() {\n        // Existing addresses:\n        // - crytic_owner: If the contract has an owner, it must be crytic_owner\n        // - crytic_user: Legitimate user\n        // - crytic_attacker: Attacker\n        //\n        // Add below a minimal configuration:\n        // - crytic_owner must have some tokens\n        // - crytic_user must have some tokens\n        // - crytic_attacker must have some tokens\n\n        // rebasingCredits = 0; // Already set by parent\n        // rebasingCreditsPerToken = 1e27;  // Already set by parent\n        vaultAddress = crytic_owner;\n        // nonRebasingSupply = 0;  // Already set by parent\n\n        initialTotalSupply = ~uint128(0);\n        initialBalance_owner = initialTotalSupply / 3;\n        _mint(crytic_owner, initialBalance_owner);\n        initialBalance_user = initialTotalSupply / 3;\n        _mint(crytic_user, initialBalance_user);\n        initialBalance_attacker = initialTotalSupply / 3;\n        _mint(crytic_attacker, initialBalance_attacker);\n    }\n}\n"
    },
    "contracts/vault/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD VaultStorage Contract\n * @notice The VaultStorage contract defines the storage for the Vault contracts\n * @author Factor Finance\n */\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IStrategy } from \"../interfaces/IStrategy.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { XUSD } from \"../token/XUSD.sol\";\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract VaultStorage is Initializable, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n    using SafeMath for int256;\n    using SafeERC20 for IERC20;\n\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event UniswapUpdated(address _address);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n    event SwapTokenAdded(address _address);\n    event SwapTokenRemoved(address _address);\n\n    // Assets supported by the Vault, i.e. Stablecoins\n    struct Asset {\n        bool isSupported;\n    }\n    mapping(address => Asset) internal assets;\n    address[] internal allAssets;\n\n    // Strategies approved for use by the Vault\n    struct Strategy {\n        bool isSupported;\n        uint256 _deprecated; // Deprecated storage slot\n    }\n    mapping(address => Strategy) internal strategies;\n    address[] internal allStrategies;\n\n    // Address of the Oracle price provider contract\n    address public priceProvider;\n    // Pausing bools\n    bool public rebasePaused = false;\n    bool public capitalPaused = true;\n    // Redemption fee in basis points\n    uint256 public redeemFeeBps;\n    // Buffer of assets to keep in Vault to handle (most) withdrawals\n    uint256 public vaultBuffer;\n    // Mints over this amount automatically allocate funds. 18 decimals.\n    uint256 public autoAllocateThreshold;\n    // Mints over this amount automatically rebase. 18 decimals.\n    uint256 public rebaseThreshold;\n\n    XUSD internal xUSD;\n\n    //keccak256(\"XUSD.vault.governor.admin.impl\");\n    bytes32 constant adminImplPosition =\n        0x10465603890dc6628fbe448d5030103026f8b8fd67cf4837783af8b8dde720a3;\n\n    // Address of the contract responsible for post rebase syncs with AMMs\n    address private _deprecated_rebaseHooksAddr = address(0);\n\n    // Address of Uniswap\n    address public uniswapAddr = address(0);\n\n    // Address of the Strategist\n    address public strategistAddr = address(0);\n\n    // Mapping of asset address to the Strategy that they should automatically\n    // be allocated to\n    mapping(address => address) public assetDefaultStrategies;\n\n    uint256 public maxSupplyDiff;\n\n    // Trustee contract that can collect a percentage of yield\n    address public trusteeAddress;\n\n    // Amount of yield collected in basis points\n    uint256 public trusteeFeeBps;\n\n    // Tokens that should be swapped for stablecoins\n    address[] public swapTokens;\n\n    /**\n     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it\n     * @param newImpl address of the implementation\n     */\n    function setAdminImpl(address newImpl) external onlyGovernor {\n        require(\n            Address.isContract(newImpl),\n            \"new implementation is not a contract\"\n        );\n        bytes32 position = adminImplPosition;\n        assembly {\n            sstore(position, newImpl)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\n */\ninterface IStrategy {\n    /**\n     * @dev Deposit the given asset to platform\n     * @param _asset asset address\n     * @param _amount Amount to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Deposit the entire balance of all supported assets in the Strategy\n     *      to the platform\n     */\n    function depositAll() external;\n\n    /**\n     * @dev Withdraw given asset from Lending platform\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Liquidate all assets in strategy and return them to Vault.\n     */\n    function withdrawAll() external;\n\n    /**\n     * @dev Returns the current balance of the given asset.\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        returns (uint256 balance);\n\n    /**\n     * @dev Returns bool indicating whether strategy supports asset.\n     */\n    function supportsAsset(address _asset) external view returns (bool);\n\n    /**\n     * @dev Collect reward tokens from the Strategy.\n     */\n    function collectRewardTokens() external;\n\n    /**\n     * @dev The address of the reward token for the Strategy.\n     */\n    function getRewardTokenAddresses() external view returns (address[] memory);\n\n    /**\n     * @dev The threshold (denominated in the reward token) over which the\n     * vault will auto harvest on allocate calls.\n     */\n    function rewardLiquidationThreshold() external pure returns (uint256);\n}\n"
    },
    "contracts/utils/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IBasicToken } from \"../interfaces/IBasicToken.sol\";\n\nlibrary Helpers {\n    /**\n     * @notice Fetch the `symbol()` from an ERC20 token\n     * @dev Grabs the `symbol()` from a contract\n     * @param _token Address of the ERC20 token\n     * @return string Symbol of the ERC20 token\n     */\n    function getSymbol(address _token) internal view returns (string memory) {\n        string memory symbol = IBasicToken(_token).symbol();\n        return symbol;\n    }\n\n    /**\n     * @notice Fetch the `decimals()` from an ERC20 token\n     * @dev Grabs the `decimals()` from a contract and fails if\n     *      the decimal value does not live within a certain range\n     * @param _token Address of the ERC20 token\n     * @return uint256 Decimals of the ERC20 token\n     */\n    function getDecimals(address _token) internal view returns (uint256) {\n        uint256 decimals = IBasicToken(_token).decimals();\n        require(\n            decimals >= 4 && decimals <= 18,\n            \"Token must have sufficient decimal places\"\n        );\n\n        return decimals;\n    }\n}\n"
    },
    "contracts/interfaces/IBasicToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IBasicToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/vault/VaultAdmin.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Vault Admin Contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Factor Finance\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { IPangolinRouter } from \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport \"./VaultStorage.sol\";\n\ncontract VaultAdmin is VaultStorage {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == address(this) ||\n                msg.sender == strategistAddr ||\n                isGovernor(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * @dev Set address of price provider.\n     * @param _priceProvider Address of price provider\n     */\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\n        priceProvider = _priceProvider;\n        emit PriceProviderUpdated(_priceProvider);\n    }\n\n    /**\n     * @dev Set a fee in basis points to be charged for a redeem.\n     * @param _redeemFeeBps Basis point fee to be charged\n     */\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\n        redeemFeeBps = _redeemFeeBps;\n        emit RedeemFeeUpdated(_redeemFeeBps);\n    }\n\n    /**\n     * @dev Set a buffer of assets to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @dev Sets the minimum amount of XUSD in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold XUSD amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set a minimum amount of XUSD in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold XUSD amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set address of Uniswap for performing liquidation of strategy reward\n     * tokens\n     * @param _address Address of Uniswap\n     */\n    function setUniswapAddr(address _address) external onlyGovernor {\n        for (uint256 i = 0; i < swapTokens.length; i++) {\n            // Revoke swap token approvals for old address\n            IERC20(swapTokens[i]).safeApprove(uniswapAddr, 0);\n        }\n        uniswapAddr = _address;\n        for (uint256 i = 0; i < swapTokens.length; i++) {\n            // Add swap token approvals for new address\n            IERC20(swapTokens[i]).safeApprove(uniswapAddr, type(uint256).max);\n        }\n        emit UniswapUpdated(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @dev Set the default Strategy for an asset, i.e. the one which the asset\n            will be automatically allocated to and withdrawn from\n     * @param _asset Address of the asset\n     * @param _strategy Address of the Strategy\n     */\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\n        // If its a zero address being passed for the strategy we are removing\n        // the default strategy\n        if (_strategy != address(0)) {\n            // Make sure the strategy meets some criteria\n            require(strategies[_strategy].isSupported, \"Strategy not approved\");\n            IStrategy strategy = IStrategy(_strategy);\n            require(assets[_asset].isSupported, \"Asset is not supported\");\n            require(\n                strategy.supportsAsset(_asset),\n                \"Asset not supported by Strategy\"\n            );\n        }\n        assetDefaultStrategies[_asset] = _strategy;\n    }\n\n    /**\n     * @dev Add a supported asset to the contract, i.e. one that can be\n     *         to mint XUSD.\n     * @param _asset Address of asset\n     */\n    function supportAsset(address _asset) external onlyGovernor {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({ isSupported: true });\n        allAssets.push(_asset);\n\n        // Verify that our oracle supports the asset\n        // slither-disable-next-line unused-return\n        IOracle(priceProvider).price(_asset);\n\n        emit AssetSupported(_asset);\n    }\n\n    /**\n     * @dev Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @dev Remove a strategy from the Vault. Removes all invested assets and\n     * returns them to the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            require(\n                assetDefaultStrategies[allAssets[i]] != _addr,\n                \"Strategy is default for an asset\"\n            );\n        }\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 strategyIndex = allStrategies.length;\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < allStrategies.length) {\n            allStrategies[strategyIndex] = allStrategies[\n                allStrategies.length - 1\n            ];\n            allStrategies.pop();\n\n            // Mark the strategy as not supported\n            strategies[_addr].isSupported = false;\n\n            // Withdraw all assets\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n\n            // Call harvest after withdraw in case withdraw triggers\n            // distribution of additional reward tokens (true for Compound)\n            _harvest(_addr);\n            emit StrategyRemoved(_addr);\n        }\n    }\n\n    /**\n     * @dev Add a swap token to the tokens that get liquidated for stablecoins\n     *      whenever swap is called. The token must have a valid feed registered\n     *      with the price provider.\n     * @param _addr Address of the token\n     */\n    function addSwapToken(address _addr) external onlyGovernor {\n        for (uint256 i = 0; i < swapTokens.length; i++) {\n            if (swapTokens[i] == _addr) {\n                revert(\"Swap token already added\");\n            }\n        }\n\n        // Revert if feed does not exist\n        IOracle(priceProvider).price(_addr);\n\n        swapTokens.push(_addr);\n\n        // Give Uniswap infinte approval\n        if (uniswapAddr != address(0)) {\n            IERC20 token = IERC20(_addr);\n            token.safeApprove(uniswapAddr, 0);\n            token.safeApprove(uniswapAddr, type(uint256).max);\n        }\n\n        emit SwapTokenAdded(_addr);\n    }\n\n    /**\n     * @dev Remove a swap token from the tokens that get liquidated for stablecoins.\n     * @param _addr Address of the token\n     */\n    function removeSwapToken(address _addr) external onlyGovernor {\n        uint256 swapTokenIndex = swapTokens.length;\n        for (uint256 i = 0; i < swapTokens.length; i++) {\n            if (swapTokens[i] == _addr) {\n                swapTokenIndex = i;\n                break;\n            }\n        }\n\n        require(swapTokenIndex != swapTokens.length, \"Swap token not added\");\n\n        // Shift everything after the index element by 1\n        for (uint256 i = swapTokenIndex; i < swapTokens.length - 1; i++) {\n            swapTokens[i] = swapTokens[i + 1];\n        }\n        swapTokens.pop();\n\n        if (uniswapAddr != address(0)) {\n            IERC20 token = IERC20(_addr);\n            // Remove Uniswap approval\n            token.safeApprove(uniswapAddr, 0);\n        }\n\n        emit SwapTokenRemoved(_addr);\n    }\n\n    /**\n     * @notice Move assets from one Strategy to another\n     * @param _strategyFromAddress Address of Strategy to move assets from.\n     * @param _strategyToAddress Address of Strategy to move assets to.\n     * @param _assets Array of asset address that will be moved\n     * @param _amounts Array of amounts of each corresponding asset to move.\n     */\n    function reallocate(\n        address _strategyFromAddress,\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        IStrategy strategyFrom = IStrategy(_strategyFromAddress);\n        IStrategy strategyTo = IStrategy(_strategyToAddress);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            require(strategyTo.supportsAsset(_assets[i]), \"Asset unsupported\");\n            // Withdraw from Strategy and pass other Strategy as recipient\n            strategyFrom.withdraw(address(strategyTo), _assets[i], _amounts[i]);\n        }\n        // Tell new Strategy to deposit into protocol\n        strategyTo.depositAll();\n    }\n\n    /**\n     * @dev Sets the maximum allowable difference between\n     * total supply and backing assets' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @dev Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @dev Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernor {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from all strategies\n     */\n    function harvest() public onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            _harvest(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Swap all supported swap tokens for stablecoins via Uniswap.\n     */\n    function swap() external onlyVaultOrGovernorOrStrategist {\n        _swap();\n    }\n\n    /*\n     * @dev Collect reward tokens from all strategies and swap for supported\n     *      stablecoin via Uniswap\n     */\n    function harvestAndSwap() external onlyGovernorOrStrategist {\n        harvest();\n        _swap();\n    }\n\n    /**\n     * @dev Collect reward tokens for a specific strategy. Called from the vault.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvest(address _strategyAddr)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        _harvest(_strategyAddr);\n    }\n\n    /**\n     * @dev Collect reward tokens for a specific strategy and swap for supported\n     *      stablecoin via Uniswap. Called from the vault.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvestAndSwap(address _strategyAddr)\n        external\n        onlyVaultOrGovernorOrStrategist\n        returns (uint256[] memory)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        _harvest(address(strategy));\n        address[] memory rewardTokenAddresses = strategy\n            .getRewardTokenAddresses();\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\n            _swap(rewardTokenAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens from a single strategy and swap them for a\n     *      supported stablecoin via Uniswap\n     * @param _strategyAddr Address of the strategy to collect rewards from.\n     */\n    function _harvest(address _strategyAddr) internal {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address[] memory rewardTokenAddresses = strategy\n            .getRewardTokenAddresses();\n        if (rewardTokenAddresses.length != 0) {\n            strategy.collectRewardTokens();\n        }\n    }\n\n    /**\n     * @dev Swap all supported swap tokens for stablecoins via Uniswap.\n     */\n    function _swap() internal {\n        for (uint256 i = 0; i < swapTokens.length; i++) {\n            _swap(swapTokens[i]);\n        }\n    }\n\n    /**\n     * @dev Swap a record token for stablecoins for Uniswap. The token must have\n     *       a registered price feed with the price provider.\n     * @param _swapToken Address of the token to swap.\n     */\n    function _swap(address _swapToken)\n        internal\n        returns (uint256[] memory swapResult)\n    {\n        if (uniswapAddr != address(0)) {\n            IERC20 swapToken = IERC20(_swapToken);\n            uint256 balance = swapToken.balanceOf(address(this));\n            if (balance > 0) {\n                // This'll revert if there is no price feed\n                uint256 oraclePrice = IOracle(priceProvider).price(_swapToken);\n                // Oracle price is 1e8, USDT output is 1e6\n                uint256 minExpected = ((balance * oraclePrice * 97) / 100)\n                    .scaleBy(6, Helpers.getDecimals(_swapToken) + 8);\n                address wavaxAddr = IPangolinRouter(uniswapAddr).WAVAX();\n\n                // Uniswap redemption path\n                address[] memory path;\n                if (_swapToken == wavaxAddr) {\n                    path = new address[](2);\n                    path[0] = _swapToken;\n                    path[1] = allAssets[1]; // USDT\n                } else {\n                    path = new address[](3);\n                    path[0] = _swapToken;\n                    path[1] = wavaxAddr;\n                    path[2] = allAssets[1]; // USDT\n                }\n\n                swapResult = IPangolinRouter(uniswapAddr)\n                    .swapExactTokensForTokens(\n                        balance,\n                        minExpected,\n                        path,\n                        address(this),\n                        block.timestamp\n                    );\n            }\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes above 1, since that is how we price mints\n     * @param asset address of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDMint(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals so scale to 18\n        return price.scaleBy(18, 8);\n    }\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Address of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDRedeem(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price < 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals so scale to 18\n        return price.scaleBy(18, 8);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @dev Withdraws all assets from the strategy and sends assets to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n    }\n\n    /**\n     * @dev Withdraws all assets from all the strategies and sends assets to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            strategy.withdrawAll();\n        }\n    }\n}\n"
    },
    "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IPangolinRouter {\n    function factory() external pure returns (address);\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountAVAX);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @dev returns the asset price in USD, 8 decimal digits.\n     */\n    function price(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/oracle/OracleRouter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract OracleRouterBase is IOracle {\n    uint256 constant MIN_DRIFT = uint256(70000000);\n    uint256 constant MAX_DRIFT = uint256(130000000);\n\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     * @return address address of the price feed for the asset\n     */\n    function feed(address asset) internal view virtual returns (address);\n\n    /**\n     * @notice Returns the total price in 8 digit USD for a given asset.\n     * @param asset address of the asset\n     * @return uint256 USD price of 1 of the asset, in 8 decimal fixed\n     */\n    function price(address asset) external view override returns (uint256) {\n        address _feed = feed(asset);\n\n        require(_feed != address(0), \"Asset not available\");\n        (, int256 _iprice, , , ) = AggregatorV3Interface(_feed)\n            .latestRoundData();\n        uint256 _price = uint256(_iprice);\n        if (isStablecoin(asset)) {\n            require(_price <= MAX_DRIFT, \"Oracle: Price exceeds max\");\n            require(_price >= MIN_DRIFT, \"Oracle: Price under min\");\n        }\n        return uint256(_price);\n    }\n\n    function isStablecoin(address _asset) internal view returns (bool) {\n        string memory symbol = Helpers.getSymbol(_asset);\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n        return\n            symbolHash == keccak256(abi.encodePacked(\"DAI.e\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDC.e\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDC\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDT.e\")) ||\n            symbolHash == keccak256(abi.encodePacked(\"USDT\"));\n    }\n}\n\ncontract OracleRouter is OracleRouterBase {\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal pure override returns (address) {\n        // DAI\n        if (asset == address(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70)) {\n            // Chainlink: DAI/USD\n            return address(0x51D7180edA2260cc4F6e4EebB82FEF5c3c2B8300);\n        } else if (\n            // USDCe\n            asset == address(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664) ||\n            // USDC\n            asset == address(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E)\n        ) {\n            // Chainlink: USDC/USD\n            return address(0xF096872672F44d6EBA71458D74fe67F9a77a23B9);\n        } else if (\n            // USDTe\n            asset == address(0xc7198437980c041c805A1EDcbA50c1Ce5db95118) ||\n            // USDT\n            asset == address(0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7)\n        ) {\n            // Chainlink: USDT/USD\n            return address(0xEBE676ee90Fe1112671f19b6B7459bC678B67e8a);\n        } else if (\n            // WAVAX\n            asset == address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7)\n        ) {\n            // Chainlink: WAVAX/USD\n            return address(0x0A77230d17318075983913bC2145DB16C7366156);\n        } else if (\n            // ALPHAe\n            asset == address(0x2147EFFF675e4A4eE1C2f918d181cDBd7a8E208f)\n        ) {\n            // Chainlink: ALPHA/USD\n            return address(0x7B0ca9A6D03FE0467A31Ca850f5bcA51e027B3aF);\n        } else if (\n            // CRVe\n            asset == address(0x249848BeCA43aC405b8102Ec90Dd5F22CA513c06)\n        ) {\n            // Chainlink: CRVe/USD\n            return address(0x7CF8A6090A9053B01F3DF4D4e6CfEdd8c90d9027);\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n\ncontract OracleRouterTestnet is OracleRouterBase {\n    /**\n     * @dev The price feed contract to use for a particular asset. Testnet hacks.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal pure override returns (address) {\n        // DAI\n        if (asset == address(0x51BC2DfB9D12d9dB50C855A5330fBA0faF761D15)) {\n            // Chainlink: USDT/USD ~1\n            return address(0x7898AcCC83587C3C55116c5230C17a6Cd9C71bad);\n        } else if (\n            // rando USDC\n            asset == address(0x3a9fC2533eaFd09Bc5C36A7D6fdd0C664C81d659)\n        ) {\n            // Chainlink: USDT/USD ~1\n            return address(0x7898AcCC83587C3C55116c5230C17a6Cd9C71bad);\n        } else if (\n            // USDTe\n            asset == address(0x02823f9B469960Bb3b1de0B3746D4b95B7E35543)\n        ) {\n            // Chainlink: USDT/USD ~1\n            return address(0x7898AcCC83587C3C55116c5230C17a6Cd9C71bad);\n        } else if (\n            // WAVAX\n            asset == address(0xd00ae08403B9bbb9124bB305C09058E32C39A48c)\n        ) {\n            // Chainlink: WAVAX/USD\n            return address(0x5498BB86BC934c8D34FDA08E81D444153d0D06aD);\n        } else if (\n            // CRVe\n            asset == address(0x249848BeCA43aC405b8102Ec90Dd5F22CA513c06)\n        ) {\n            // Chainlink: CRV/USD\n            return address(0x7CF8A6090A9053B01F3DF4D4e6CfEdd8c90d9027);\n        } else {\n            revert(\"Asset not available\");\n        }\n    }\n}\n\ncontract OracleRouterDev is OracleRouterBase {\n    mapping(address => address) public assetToFeed;\n\n    function setFeed(address _asset, address _feed) external {\n        assetToFeed[_asset] = _feed;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal view override returns (address) {\n        return assetToFeed[asset];\n    }\n}\n"
    },
    "contracts/interfaces/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/strategies/CurvePoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Pool Strategy\n * @notice Investment strategy for investing in Curve Pools\n * @author Origin Protocol Inc\n * @author Factor Finance 2022\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\nimport { IERC20, BaseCurveStrategy } from \"./BaseCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\ncontract CurveUsdcStrategy is BaseCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address internal crvGaugeAddress;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _platformAddress Address of the Curve pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddresses Address of reward\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                USDC, USDCe\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _crvGaugeAddress Address of the Curve DAO gauge for this pool\n     */\n    function initialize(\n        address _platformAddress, // Pool address\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses, // [CRV, WAVAX]\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _crvGaugeAddress\n    ) external onlyGovernor initializer {\n        require(_assets.length == 2, \"Must have exactly two assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        crvGaugeAddress = _crvGaugeAddress;\n        pTokenAddress = _pTokens[0];\n        super._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    function _lpDepositAll() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Deposit into Gauge\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    function _lpWithdraw(uint256 numPTokens) internal override {\n        // Not enough of pool token exists on this contract, some must be\n        // staked in Gauge, unstake difference\n        ICurveGauge(crvGaugeAddress).withdraw(numPTokens);\n    }\n\n    /**\n     * @dev Calculate the total platform token balance (i.e. 3CRV) that exist in\n     * this contract or is staked in the Gauge (or in other words, the total\n     * amount platform tokens we own).\n     * @return contractPTokens Amount of platform tokens in this contract\n     * @return gaugePTokens Amount of platform tokens staked in gauge\n     * @return totalPTokens Total amount of platform tokens in native decimals\n     */\n    function _getTotalPTokens()\n        internal\n        view\n        override\n        returns (\n            uint256 contractPTokens,\n            uint256 gaugePTokens,\n            uint256 totalPTokens\n        )\n    {\n        contractPTokens = IERC20(pTokenAddress).balanceOf(address(this));\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        gaugePTokens = gauge.balanceOf(address(this));\n        totalPTokens = contractPTokens + gaugePTokens;\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        pToken.safeApprove(crvGaugeAddress, 0);\n        pToken.safeApprove(crvGaugeAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Collect accumulated rewards and send to Vault.\n     */\n    function collectRewardTokens() external override onlyVault nonReentrant {\n        // Collect rewards directly to the vault.\n        // N.B. if there are new rewards, we do not need to transfer them.\n        ICurveGauge(crvGaugeAddress).claim_rewards(address(this), vaultAddress);\n        // FIXME: for each reward token: compute diff on vault and emit amounts claimed\n        // emit RewardTokenCollected(vaultAddress, amount);\n    }\n}\n"
    },
    "contracts/strategies/ICurveGauge.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface ICurveGauge {\n    function balanceOf(address account) external view returns (uint256);\n\n    function deposit(uint256 value, address account) external;\n\n    function withdraw(uint256 value) external;\n\n    function claim_rewards(address _sender, address _receiver) external;\n}\n"
    },
    "contracts/strategies/BaseCurveStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Pool Strategy\n * @notice Investment strategy for investing in Curve Pools\n * @author Origin Protocol Inc\n * @author Factor Finance 2022\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract BaseCurveStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant maxSlippage = 1e16; // 1%, same as the Curve UI\n    address internal pTokenAddress;\n\n    /**\n     * @dev Deposit asset into the Curve Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(platformAddress), _amount);\n        // Pools requires passing deposit amounts for all assets, set to 0 for\n        // all\n        uint256[2] memory _amounts;\n        uint256 poolCoinIndex = _getCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount.scaleBy(18, assetDecimals).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n        // Do the deposit to pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        _lpDepositAll();\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256[2] memory _amounts = [uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 curveVirtualPrice = curvePool.get_virtual_price();\n\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue =\n                    depositValue +\n                    balance.scaleBy(18, assetDecimals).divPrecisely(\n                        curveVirtualPrice\n                    );\n                emit Deposit(assetAddress, address(platformAddress), balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18) - maxSlippage\n        );\n        // Do the deposit to pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge, the PToken is the same (USDC/USDCe) for all mapped\n        // assets, so just get the address from the first one\n        _lpDepositAll();\n    }\n\n    function _lpWithdraw(uint256 numPTokens) internal virtual;\n\n    /**\n     * @dev Withdraw asset from Curve Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, address(assetToPToken[_asset]), _amount);\n\n        (uint256 contractPTokens, , uint256 totalPTokens) = _getTotalPTokens();\n\n        uint256 coinIndex = _getCoinIndex(_asset);\n        int128 curveCoinIndex = int128(uint128(coinIndex));\n        // Calculate the max amount of the asset we'd get if we withdrew all the\n        // platform tokens\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        // Calculate how many platform tokens we need to withdraw the asset\n        // amount in the worst case (i.e withdrawing all LP tokens)\n        uint256 maxAmount = curvePool.calc_withdraw_one_coin(\n            totalPTokens,\n            curveCoinIndex\n        );\n        uint256 maxBurnedPTokens = (totalPTokens * _amount) / maxAmount;\n\n        // Not enough in this contract or in the Gauge, can't proceed\n        require(\n            totalPTokens > maxBurnedPTokens,\n            \"Insufficient USDC-USDCe balance\"\n        );\n        // We have enough LP tokens, make sure they are all on this contract\n        if (contractPTokens < maxBurnedPTokens) {\n            _lpWithdraw(maxBurnedPTokens - contractPTokens);\n        }\n\n        uint256[2] memory _amounts = [uint256(0), uint256(0)];\n        _amounts[coinIndex] = _amount;\n        curvePool.remove_liquidity_imbalance(_amounts, maxBurnedPTokens);\n\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // Withdraw all from Gauge\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\n        _lpWithdraw(gaugePTokens);\n        // Withdraws are proportional to assets held by Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n        // Remove liquidity\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        curvePool.remove_liquidity(totalPTokens, minWithdrawAmounts);\n        // Transfer assets out of Vault\n        // Note that Curve will provide all of the assets in pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(curvePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        (, , uint256 totalPTokens) = _getTotalPTokens();\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (totalPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = (totalPTokens * virtual_price) / 1e18;\n            uint256 assetDecimals = Helpers.getDecimals(_asset);\n            balance = value.scaleBy(assetDecimals, 18) / 2;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveBase();\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _approveAsset(assetsMapped[i]);\n        }\n    }\n\n    /**\n     * @dev Calculate the total platform token balance (i.e. USDC-USDCe) that exist in\n     * this contract or is staked in the Gauge (or in other words, the total\n     * amount platform tokens we own).\n     * @return contractPTokens Amount of platform tokens in this contract\n     * @return gaugePTokens Amount of platform tokens staked in gauge\n     * @return totalPTokens Total amount of platform tokens in native decimals\n     */\n    function _getTotalPTokens()\n        internal\n        view\n        virtual\n        returns (\n            uint256 contractPTokens,\n            uint256 gaugePTokens,\n            uint256 totalPTokens\n        );\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal virtual;\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 2; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid pool asset\");\n    }\n}\n"
    },
    "contracts/strategies/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[2] calldata _amounts, uint256 _min) external;\n\n    function balances(uint256) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata _amounts, bool _deposit)\n        external\n        returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        uint256 _minAmount\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[2] calldata _minWithdrawAmounts\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        external\n        view\n        returns (uint256);\n\n    function coins(uint256 _index) external view returns (address);\n\n    function remove_liquidity_imbalance(\n        uint256[2] calldata _amounts,\n        uint256 maxBurnAmount\n    ) external;\n}\n"
    },
    "contracts/utils/InitializableAbstractStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { Initializable } from \"../utils/Initializable.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\nabstract contract InitializableAbstractStrategy is Initializable, Governable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event PTokenAdded(address indexed _asset, address _pToken);\n    event PTokenRemoved(address indexed _asset, address _pToken);\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\n    event RewardTokenCollected(\n        address recipient,\n        address rewardToken,\n        uint256 amount\n    );\n    event RewardTokenAddressesUpdated(\n        address[] _oldAddresses,\n        address[] _newAddresses\n    );\n    event RewardTokenAddressUpdated(address _oldAddress, address _newAddress);\n    event RewardLiquidationThresholdUpdated(\n        uint256 _oldThreshold,\n        uint256 _newThreshold\n    );\n\n    // Core address for the given platform\n    address public platformAddress;\n\n    address public vaultAddress;\n\n    // asset => pToken (Platform Specific Token Address)\n    mapping(address => address) public assetToPToken;\n\n    // Full list of all assets supported here\n    address[] internal assetsMapped;\n\n    // Deprecated: Reward token address\n    // slither-disable-next-line constable-states\n    address public _deprecated_rewardTokenAddress;\n\n    // Liquidation threshold for any of rewardTokens\n    uint256 public rewardLiquidationThreshold;\n\n    // Reward token addresses\n    address[] public rewardTokenAddresses;\n\n    // Reserved for future expansion\n    int256[99] private _reserved;\n\n    /**\n     * @dev Internal initialize function, to set up initial internal state\n     * @param _platformAddress Generic platform address\n     * @param _vaultAddress Address of the Vault\n     * @param _rewardTokenAddresses Addresses of reward tokens for platform\n     * @param _assets Addresses of initial supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external onlyGovernor initializer {\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    function _initialize(\n        address _platformAddress,\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses,\n        address[] memory _assets,\n        address[] memory _pTokens\n    ) internal {\n        platformAddress = _platformAddress;\n        vaultAddress = _vaultAddress;\n        rewardTokenAddresses = _rewardTokenAddresses;\n        uint256 assetCount = _assets.length;\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\n        for (uint256 i = 0; i < assetCount; i++) {\n            _setPTokenAddress(_assets[i], _pTokens[i]);\n        }\n    }\n\n    /**\n     * @dev Collect accumulated reward token and send to Vault.\n     */\n    function collectRewardTokens() external virtual onlyVault nonReentrant {\n        _collectRewardTokens();\n    }\n\n    function _collectRewardTokens() internal {\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\n            IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            emit RewardTokenCollected(\n                vaultAddress,\n                rewardTokenAddresses[i],\n                balance\n            );\n            rewardToken.safeTransfer(vaultAddress, balance);\n        }\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault.\n     */\n    modifier onlyVault() {\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the caller is the Vault or Governor.\n     */\n    modifier onlyVaultOrGovernor() {\n        require(\n            msg.sender == vaultAddress || msg.sender == governor(),\n            \"Caller is not the Vault or Governor\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set the reward token addresses.\n     * @param _rewardTokenAddresses Address array of the reward tokens\n     */\n    function setRewardTokenAddresses(address[] calldata _rewardTokenAddresses)\n        external\n        onlyGovernor\n    {\n        for (uint256 i = 0; i < _rewardTokenAddresses.length; i++) {\n            require(\n                _rewardTokenAddresses[i] != address(0),\n                \"Can not set an empty address as a reward token\"\n            );\n        }\n\n        emit RewardTokenAddressesUpdated(\n            rewardTokenAddresses,\n            _rewardTokenAddresses\n        );\n        rewardTokenAddresses = _rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Set the reward token liquidation threshold.\n     * @param _threshold Threshold amount in decimals of reward token that will\n     * cause the Vault to claim and withdrawAll on allocate() calls.\n     */\n    function setRewardLiquidationThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        emit RewardLiquidationThresholdUpdated(\n            rewardLiquidationThreshold,\n            _threshold\n        );\n        rewardLiquidationThreshold = _threshold;\n    }\n\n    /**\n     * @dev Get the reward token addresses.\n     * @return address[] the reward token addresses.\n     */\n    function getRewardTokenAddresses()\n        external\n        view\n        returns (address[] memory)\n    {\n        return rewardTokenAddresses;\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      This method can only be called by the system Governor\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function setPTokenAddress(address _asset, address _pToken)\n        external\n        onlyGovernor\n    {\n        _setPTokenAddress(_asset, _pToken);\n    }\n\n    /**\n     * @dev Remove a supported asset by passing its index.\n     *      This method can only be called by the system Governor\n     * @param _assetIndex Index of the asset to be removed\n     */\n    function removePToken(uint256 _assetIndex) external onlyGovernor {\n        require(_assetIndex < assetsMapped.length, \"Invalid index\");\n        address asset = assetsMapped[_assetIndex];\n        address pToken = assetToPToken[asset];\n\n        if (_assetIndex < assetsMapped.length - 1) {\n            assetsMapped[_assetIndex] = assetsMapped[assetsMapped.length - 1];\n        }\n        assetsMapped.pop();\n        assetToPToken[asset] = address(0);\n\n        emit PTokenRemoved(asset, pToken);\n    }\n\n    /**\n     * @dev Provide support for asset by passing its pToken address.\n     *      Add to internal mappings and execute the platform specific,\n     * abstract method `_abstractSetPToken`\n     * @param _asset    Address for the asset\n     * @param _pToken   Address for the corresponding platform token\n     */\n    function _setPTokenAddress(address _asset, address _pToken) internal {\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\n        require(\n            _asset != address(0) && _pToken != address(0),\n            \"Invalid addresses\"\n        );\n\n        assetToPToken[_asset] = _pToken;\n        assetsMapped.push(_asset);\n\n        emit PTokenAdded(_asset, _pToken);\n\n        _abstractSetPToken(_asset, _pToken);\n    }\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      strategy contracts, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        public\n        onlyGovernor\n    {\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /***************************************\n                 Abstract\n    ****************************************/\n\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        virtual;\n\n    function safeApproveAllTokens() external virtual;\n\n    /**\n     * @dev Deposit an amount of asset into the platform\n     * @param _asset               Address for the asset\n     * @param _amount              Units of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external virtual;\n\n    /**\n     * @dev Deposit balance of all supported assets into the platform\n     */\n    function depositAll() external virtual;\n\n    /**\n     * @dev Withdraw an amount of asset from the platform.\n     * @param _recipient         Address to which the asset should be sent\n     * @param _asset             Address of the asset\n     * @param _amount            Units of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external virtual;\n\n    /**\n     * @dev Withdraw all assets from strategy sending assets to Vault.\n     */\n    function withdrawAll() external virtual;\n\n    /**\n     * @dev Get the total asset value held in the platform.\n     *      This includes any interest that was generated since depositing.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        returns (uint256 balance);\n\n    /**\n     * @dev Check if an asset is supported.\n     * @param _asset    Address of the asset\n     * @return bool     Whether asset is supported\n     */\n    function supportsAsset(address _asset) external view virtual returns (bool);\n}\n"
    },
    "contracts/strategies/AlphaHomoraStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD AlphaHomora Strategy\n * @notice Investment strategy for investing stablecoins via AlphaHomora/CREAM\n * @author XUSD.fi Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { ICERC20 } from \"../interfaces/alphaHomora/ICERC20.sol\";\nimport { ISafeBox } from \"../interfaces/alphaHomora/ISafeBox.sol\";\nimport { IAlphaIncentiveDistributor } from \"../interfaces/alphaHomora/IAlphaIncentiveDistributor.sol\";\n\ncontract AlphaHomoraStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    address[] public incentiveDistributorAddresses;\n    mapping(address => bytes32[]) internal _proofs;\n    mapping(address => uint256) internal _amounts;\n\n    function initialize(\n        address _platformAddress, // dead\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses, // [ALPHA, WAVAX]\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address[] calldata _incentiveDistributorAddresses // [ALPHAcontrollerAddr, WAVAXcontrollerAddr]\n    ) external onlyGovernor initializer {\n        require(\n            _rewardTokenAddresses.length ==\n                _incentiveDistributorAddresses.length,\n            \"not 1:1 rewards-to-incentives\"\n        );\n        incentiveDistributorAddresses = _incentiveDistributorAddresses;\n\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    event SkippedWithdrawal(address asset, uint256 amount);\n\n    /**\n     * @dev Collect accumulated WAVAX+ALPHA and send to Vault.\n     */\n    function collectRewardTokens() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < rewardTokenAddresses.length; i++) {\n            IAlphaIncentiveDistributor _incentiveDistributor = IAlphaIncentiveDistributor(\n                    incentiveDistributorAddresses[i]\n                );\n            require(_incentiveDistributor.token() == rewardTokenAddresses[i]);\n            uint256 _amount = _amounts[rewardTokenAddresses[i]];\n            if (_amount == 0) {\n                continue;\n            }\n            bytes32[] memory _proof = _proofs[rewardTokenAddresses[i]];\n            uint256 _claimed = _incentiveDistributor.claimed(address(this));\n            if (_claimed < _amount) {\n                /* Claim _amount - _claimed reward tokens */\n                _incentiveDistributor.claim(address(this), _amount, _proof);\n                /* // Transfer rewards to Vault */\n                IERC20 rewardToken = IERC20(rewardTokenAddresses[i]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                emit RewardTokenCollected(\n                    vaultAddress,\n                    rewardTokenAddresses[i],\n                    balance\n                );\n                rewardToken.safeTransfer(vaultAddress, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Deposit asset into AlphaHomora\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into AlphaHomorax\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        ISafeBox safeBox = _getSafeBoxFor(_asset);\n        emit Deposit(_asset, address(safeBox), _amount);\n        safeBox.deposit(_amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into AlphaHomora\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from AlphaHomora\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        ISafeBox safeBox = _getSafeBoxFor(_asset);\n        ICERC20 cToken = _getCTokenFor(_asset);\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\n        emit Withdrawal(_asset, address(safeBox), cTokensToRedeem);\n        if (cTokensToRedeem == 0) {\n            emit SkippedWithdrawal(_asset, _amount);\n            return;\n        }\n        emit Withdrawal(_asset, address(cToken.underlying()), _amount);\n        uint256 balanceBefore = IERC20(_asset).balanceOf(address(this));\n        safeBox.withdraw(cTokensToRedeem);\n        uint256 balanceAfter = IERC20(_asset).balanceOf(address(this));\n        require(\n            _amount <= balanceAfter - balanceBefore,\n            \"Did not withdraw enough\"\n        );\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send all of that asset to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(assetsMapped[i]);\n            ISafeBox safeBox = _getSafeBoxFor(assetsMapped[i]);\n            ICERC20 cToken = _getCTokenFor(assetsMapped[i]);\n            uint256 balance = cToken.balanceOf(address(this));\n            // Redeem entire balance of safeBox\n            if (balance > 0) {\n                safeBox.withdraw(balance);\n                // Transfer entire balance to Vault, including any already held\n                asset.safeTransfer(\n                    vaultAddress,\n                    asset.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      This includes any interest that was generated since depositing\n     *      CREAM exchange rate between the cToken and asset gradually increases,\n     *      causing the cToken to be worth more corresponding asset.\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token cToken decimals\n        address safeBoxAddr = assetToPToken[_asset];\n        require(safeBoxAddr != address(0));\n        ISafeBox _safeBox = _getSafeBoxFor(_asset);\n        ICERC20 _cToken = _safeBox.cToken();\n        balance = _checkBalance(safeBoxAddr, _cToken);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\n     * @param _cToken     cToken for which to check balance\n     * @return balance    Total value of the asset in the platform\n     */\n    function _checkBalance(address _safeBox, ICERC20 _cToken)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        uint256 safeBoxBalance = IERC20(_safeBox).balanceOf(address(this));\n        uint256 exchangeRate = _cToken.exchangeRateStored();\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\n        balance = (safeBoxBalance * exchangeRate) / 1e18;\n    }\n\n    /**\n     * @dev Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external override {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; i++) {\n            address asset = assetsMapped[i];\n            address cToken = assetToPToken[asset];\n            // Safe approval\n            IERC20(asset).safeApprove(cToken, 0);\n            IERC20(asset).safeApprove(cToken, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / cTokens\n     *      We need to approve the cToken and give it permission to spend the asset\n     * @param _asset Address of the asset to approve\n     * @param _cToken The cToken for the approval\n     */\n    function _abstractSetPToken(address _asset, address _cToken)\n        internal\n        override\n    {\n        // Safe approval\n        IERC20(_asset).safeApprove(_cToken, 0);\n        IERC20(_asset).safeApprove(_cToken, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the SafeBox token wrap ISafeBox interface for this asset.\n     *      Fails if the SafeBbox doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding SafeBox to this asset\n     */\n    function _getSafeBoxFor(address _asset) internal view returns (ISafeBox) {\n        address safeBox = assetToPToken[_asset];\n        require(safeBox != address(0), \"safeBox does not exist\");\n        return ISafeBox(safeBox);\n    }\n\n    /**\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\n     *      Fails if the cToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding cToken to this asset\n     */\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\n        ISafeBox safeBox = _getSafeBoxFor(_asset);\n        return ICERC20(safeBox.cToken());\n    }\n\n    /**\n     * @dev Converts an underlying amount into cToken amount\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\n     * @param _cToken     cToken for which to change\n     * @param _underlying Amount of underlying to convert\n     * @return amount     Equivalent amount of cTokens\n     */\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        uint256 exchangeRate = _cToken.exchangeRateStored();\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\n        amount = (_underlying * 1e18) / exchangeRate;\n    }\n\n    /**\n     * @dev Sets the reward amount and merkle proof from off-chain.\n     * @param _rewardTokenAddress The reward token address\n     * @param proof the MerkleProof provided by AlphaHomora\n     * @param amount The accumulated (total) amount of rewards.\n     */\n    function setProofAndAmount(\n        address _rewardTokenAddress,\n        bytes32[] calldata proof,\n        uint256 amount\n    ) external onlyGovernorOrStrategist {\n        _proofs[_rewardTokenAddress] = proof;\n        _amounts[_rewardTokenAddress] = amount;\n    }\n\n    function getProofAndAmount(address _rewardTokenAddress)\n        external\n        view\n        returns (bytes32[] memory, uint256)\n    {\n        return (_proofs[_rewardTokenAddress], _amounts[_rewardTokenAddress]);\n    }\n\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == IVault(vaultAddress).strategistAddr() || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IVault {\n    event AssetSupported(address _asset);\n    event AssetDefaultStrategyUpdated(address _asset, address _strategy);\n    event AssetAllocated(address _asset, address _strategy, uint256 _amount);\n    event StrategyApproved(address _addr);\n    event StrategyRemoved(address _addr);\n    event Mint(address _addr, uint256 _value);\n    event Redeem(address _addr, uint256 _value);\n    event CapitalPaused();\n    event CapitalUnpaused();\n    event RebasePaused();\n    event RebaseUnpaused();\n    event VaultBufferUpdated(uint256 _vaultBuffer);\n    event RedeemFeeUpdated(uint256 _redeemFeeBps);\n    event PriceProviderUpdated(address _priceProvider);\n    event AllocateThresholdUpdated(uint256 _threshold);\n    event RebaseThresholdUpdated(uint256 _threshold);\n    event UniswapUpdated(address _address);\n    event StrategistUpdated(address _address);\n    event MaxSupplyDiffChanged(uint256 maxSupplyDiff);\n    event YieldDistribution(address _to, uint256 _yield, uint256 _fee);\n    event TrusteeFeeBpsChanged(uint256 _basis);\n    event TrusteeAddressChanged(address _address);\n\n    // Governable.sol\n    function transferGovernance(address _newGovernor) external;\n\n    function claimGovernance() external;\n\n    function governor() external view returns (address);\n\n    // VaultAdmin.sol\n    function setPriceProvider(address _priceProvider) external;\n\n    function priceProvider() external view returns (address);\n\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\n\n    function redeemFeeBps() external view returns (uint256);\n\n    function setVaultBuffer(uint256 _vaultBuffer) external;\n\n    function vaultBuffer() external view returns (uint256);\n\n    function setAutoAllocateThreshold(uint256 _threshold) external;\n\n    function autoAllocateThreshold() external view returns (uint256);\n\n    function setRebaseThreshold(uint256 _threshold) external;\n\n    function rebaseThreshold() external view returns (uint256);\n\n    function setStrategistAddr(address _address) external;\n\n    function strategistAddr() external view returns (address);\n\n    function setUniswapAddr(address _address) external;\n\n    function uniswapAddr() external view returns (address);\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external;\n\n    function maxSupplyDiff() external view returns (uint256);\n\n    function setTrusteeAddress(address _address) external;\n\n    function trusteeAddress() external view returns (address);\n\n    function setTrusteeFeeBps(uint256 _basis) external;\n\n    function trusteeFeeBps() external view returns (uint256);\n\n    function supportAsset(address _asset) external;\n\n    function approveStrategy(address _addr) external;\n\n    function removeStrategy(address _addr) external;\n\n    function addSwapToken(address _addr) external;\n\n    function removeSwapToken(address _addr) external;\n\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external;\n\n    function assetDefaultStrategies(address _asset)\n        external\n        view\n        returns (address);\n\n    function pauseRebase() external;\n\n    function unpauseRebase() external;\n\n    function rebasePaused() external view returns (bool);\n\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n\n    function capitalPaused() external view returns (bool);\n\n    function transferToken(address _asset, uint256 _amount) external;\n\n    function harvest() external;\n\n    function harvestAndSwap() external;\n\n    function harvest(address _strategyAddr) external;\n\n    function harvestAndSwap(address _strategyAddr) external;\n\n    function swap() external;\n\n    function priceUSDMint(address asset) external view returns (uint256);\n\n    function priceUSDRedeem(address asset) external view returns (uint256);\n\n    function withdrawAllFromStrategy(address _strategyAddr) external;\n\n    function withdrawAllFromStrategies() external;\n\n    function reallocate(\n        address _strategyFromAddress,\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external;\n\n    // VaultCore.sol\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumXusdAmount\n    ) external;\n\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount) external;\n\n    function redeemAll(uint256 _minimumUnitAmount) external;\n\n    function allocate() external;\n\n    function rebase() external;\n\n    function totalValue() external view returns (uint256 value);\n\n    function checkBalance(address _asset) external view returns (uint256);\n\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getAssetCount() external view returns (uint256);\n\n    function getAllAssets() external view returns (address[] memory);\n\n    function getStrategyCount() external view returns (uint256);\n\n    function isSupportedAsset(address _asset) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/alphaHomora/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICERC20 {\n    function decimals() external returns (uint8);\n\n    function underlying() external returns (address);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/alphaHomora/ISafeBox.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ICERC20 } from \"./ICERC20.sol\";\n\ninterface ISafeBox {\n    function cToken() external view returns (ICERC20);\n\n    function uToken() external view returns (IERC20);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function claim(uint256 totalAmount, bytes32[] memory proof) external;\n\n    function claimAndWithdraw(\n        uint256 totalAmount,\n        bytes32[] memory proof,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "contracts/interfaces/alphaHomora/IAlphaIncentiveDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IAlphaIncentiveDistributor {\n    // closed source.\n    // extracted from: https://snowtrace.io/address/0x7424ddc7ac9f60b3d0f7bca9e438dc2c1d44d043 (alpha)\n    //                       and 0xf40d48bb67508538bfab8091a919d2659a944b16 (wavax)\n    // Returns the address of the token distributed by this contract.\n    function token() external view returns (address);\n\n    function claim(\n        address _account,\n        uint256 _reward,\n        bytes32[] calldata _proof\n    ) external;\n\n    function claimed(address _account) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/mocks/MockAlphaHomora.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { ICERC20 } from \"../interfaces/alphaHomora/ICERC20.sol\";\nimport { ISafeBox } from \"../interfaces/alphaHomora/ISafeBox.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// https://alphafinancelab.gitbook.io/alpha-homora-developer-doc/become-the-leader-of-alpha-homora-v2\n// 1. User calls 'deposit' (AlphaHomora)\n//  - Deposit their underlying stablecoin[<8;60;9m]\n//  - Mint cToken to them\n// 2. User calls withdraw (cToken)\n//  - Retrieve their cToken\n//  - Return underlying + interest (using exchangeRate)\n\ncontract MockCERC20 is ICERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n    uint256 public interestPerYear = 10e16; // 10% per year\n    uint256 exchangeRate = 1e18;\n    uint256 public mintRate = 1e18;\n    uint256 public totalSupply = 0;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => uint256) public borrows;\n    mapping(address => uint256) public lastBlock;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function decimals() external override returns (uint8) {\n        return 8;\n    }\n\n    function underlying() external override returns (address) {\n        return address(token);\n    }\n\n    function setMintRate(uint256 _mintRate) external {\n        mintRate = _mintRate;\n    }\n\n    function mint(uint256 mintAmount) external override returns (uint256) {\n        uint256 amountIn = mintAmount.mul(mintRate).div(1e18);\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n        totalSupply = totalSupply.add(mintAmount);\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(mintAmount);\n        return 0;\n    }\n\n    function redeem(uint256 redeemAmount) external override returns (uint256) {\n        uint256 amountOut = redeemAmount.mul(1e18).div(mintRate);\n        IERC20(token).safeTransfer(msg.sender, amountOut);\n        totalSupply = totalSupply.sub(redeemAmount);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(redeemAmount);\n        return 0;\n    }\n\n    function setMockExchangeRate() external {\n        // 1% more\n        exchangeRate = 1e18 + 1e16;\n        // create enough DAI to pay back\n        // do not make it too complicated\n    }\n\n    function exchangeRateCurrent() external override returns (uint256) {\n        // https://github.com/CreamFi/cream-deployment/blob/avax/contracts/CToken.sol#L268-L283\n        return exchangeRate;\n    }\n\n    function exchangeRateStored() external view override returns (uint256) {\n        return 1e18;\n    }\n}\n\ncontract MockSafeBox is ISafeBox, ReentrancyGuard, ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    ICERC20 public immutable override cToken;\n    IERC20 public immutable override uToken;\n    MintableERC20 public REWARD_TOKEN;\n\n    bytes32 public root;\n    mapping(address => uint256) public rewards;\n\n    constructor(\n        ICERC20 _cToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        IERC20 _uToken = IERC20(_cToken.underlying());\n        cToken = _cToken;\n        uToken = _uToken;\n        // MAX_INT\n        _uToken.safeApprove(address(_cToken), uint256(2**256 - 1));\n    }\n\n    function setRewardsBalance(address user, uint256 amount) external {\n        rewards[user] = amount;\n    }\n\n    function deposit(uint256 amount) external override nonReentrant {\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        uToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n        uint256 cBalanceBefore = cToken.balanceOf(address(this));\n        require(cToken.mint(uBalanceAfter.sub(uBalanceBefore)) == 0, \"!mint\");\n        uint256 cBalanceAfter = cToken.balanceOf(address(this));\n        _mint(msg.sender, cBalanceAfter.sub(cBalanceBefore));\n    }\n\n    function withdraw(uint256 amount) public override nonReentrant {\n        _burn(msg.sender, amount);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        require(cToken.redeem(amount) == 0, \"!redeem\");\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n        uToken.safeTransfer(msg.sender, uBalanceAfter.sub(uBalanceBefore));\n    }\n\n    function claim(uint256 totalAmount, bytes32[] memory proof)\n        public\n        override\n        nonReentrant\n    {\n        require(totalAmount > 0);\n        REWARD_TOKEN.mint(totalAmount);\n        require(rewards[msg.sender] == totalAmount);\n        require(REWARD_TOKEN.transfer(msg.sender, totalAmount));\n        rewards[msg.sender] = 0;\n    }\n\n    function claimAndWithdraw(\n        uint256 totalAmount,\n        bytes32[] memory proof,\n        uint256 withdrawAmount\n    ) external override {\n        claim(totalAmount, proof);\n        withdraw(withdrawAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/mocks/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IMintableERC20 {\n    function mint(uint256 value) external;\n\n    function mintTo(address to, uint256 value) external;\n}\n\n/**\n * @title MintableERC20\n * @dev Exposes the mint function of ERC20 for tests\n */\nabstract contract MintableERC20 is IMintableERC20, ERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param _value The amount of tokens to mint.\n     */\n    function mint(uint256 _value) public virtual override {\n        _mint(msg.sender, _value);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to Address to mint to.\n     * @param _value The amount of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _value) public virtual override {\n        _mint(_to, _value);\n    }\n}\n"
    },
    "contracts/mocks/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDT is MintableERC20 {\n    constructor() ERC20(\"USDT Coin\", \"USDT\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockUSDCNative.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDCNative is MintableERC20 {\n    constructor() ERC20(\"USDC Coin\", \"USDC\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockUSDC is MintableERC20 {\n    constructor() ERC20(\"Ethereum-wrapped USDC Coin\", \"USDCe\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockTUSD.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockTUSD is MintableERC20 {\n    constructor() ERC20(\"TrueUSD\", \"TUSD\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockNonStandardToken.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./MintableERC20.sol\";\n\n/**\n * Mock token contract to simulate tokens that don't\n * throw/revert when a transfer/transferFrom call fails\n */\ncontract MockNonStandardToken is MintableERC20 {\n    using SafeMath for uint256;\n\n    constructor() ERC20(\"NonStandardToken\", \"NonStandardToken\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        if (balanceOf(msg.sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        if (balanceOf(sender) < amount) {\n            // Fail silently\n            return false;\n        }\n\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            allowance(sender, _msgSender()).sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n}\n"
    },
    "contracts/vault/VaultCore.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Vault Contract\n * @notice The Vault contract stores assets. On a deposit, XUSD will be minted\n           and sent to the depositor. On a withdrawal, XUSD will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest from yield bearing strategies which will modify the supply\n           of XUSD.\n * @author Factor Finance\n */\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IBuyback } from \"../interfaces/IBuyback.sol\";\nimport \"./VaultStorage.sol\";\n\ncontract VaultCore is VaultStorage {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n    using SafeMath for uint256;\n\n    uint256 constant MAX_UINT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint XUSD.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumXusdAmount Minimum XUSD to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumXusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 price = IOracle(priceProvider).price(_asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        // Scale up to 18 decimal\n        uint256 unitAdjustedDeposit = _amount.scaleBy(18, assetDecimals);\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\n            price.scaleBy(18, 8), // Oracles have 8 decimal precision\n            10**assetDecimals\n        );\n\n        if (_minimumXusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumXusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching XUSD\n        xUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (unitAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    // In memoriam\n\n    /**\n     * @dev Withdraw a supported asset and burn XUSD.\n     * @param _amount Amount of XUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn XUSD.\n     * @param _amount Amount of XUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Calculate redemption outputs\n        (\n            uint256[] memory outputs,\n            uint256 _backingValue\n        ) = _calculateRedeemOutputs(_amount);\n\n        // Check that XUSD is backed by enough assets\n        uint256 _totalSupply = xUSD.totalSupply();\n        if (maxSupplyDiff > 0) {\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and XUSD total supply\n            uint256 diff = _totalSupply.divPrecisely(_backingValue);\n            require(\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\n                    maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            if (outputs[i] == 0) continue;\n\n            IERC20 asset = IERC20(allAssets[i]);\n\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                asset.safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[allAssets[i]];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; i++) {\n                uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                unitTotal = unitTotal.add(\n                    outputs[i].scaleBy(18, assetDecimals)\n                );\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        xUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        if (_amount > rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all XUSD.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(xUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() external whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal {\n        // Harvest for all reward tokens above reward liquidation threshold.\n        // Harvesting is the first action that takes place so we have an up to\n        // date picture of total assets before allocating to strategies.\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            address[] memory rewardTokenAddresses = strategy\n                .getRewardTokenAddresses();\n            for (uint256 j = 0; j < rewardTokenAddresses.length; j++) {\n                if (rewardTokenAddresses[j] != address(0)) {\n                    uint256 liquidationThreshold = strategy\n                        .rewardLiquidationThreshold();\n                    if (liquidationThreshold == 0) {\n                        // No threshold set, always harvest from strategy\n                        IVault(address(this)).harvestAndSwap(allStrategies[i]);\n                    } else {\n                        // Check balance against liquidation threshold\n                        // Note some strategies don't hold the reward token balance\n                        // on their contract so the liquidation threshold should be\n                        // set to 0\n                        IERC20 rewardToken = IERC20(rewardTokenAddresses[j]);\n                        uint256 rewardTokenAmount = rewardToken.balanceOf(\n                            allStrategies[i]\n                        );\n                        if (rewardTokenAmount >= liquidationThreshold) {\n                            IVault(address(this)).harvestAndSwap(\n                                allStrategies[i]\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\n        } else {\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\n                vaultValue\n            );\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate to the appropriate\n        // strategy\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[\n                address(asset)\n            ];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n                emit AssetAllocated(\n                    address(asset),\n                    depositStrategyAddr,\n                    allocateAmount\n                );\n            }\n        }\n\n        // Trigger OGN Buyback\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0)) {\n            IBuyback(trusteeAddress).swap();\n        }\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of XUSD.\n     */\n    function rebase() external virtual nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of XUSD, optionally sending a\n     *      portion of the yield to the trustee.\n     */\n    function _rebase() internal whenNotRebasePaused {\n        uint256 xusdSupply = xUSD.totalSupply();\n        if (xusdSupply == 0) {\n            return;\n        }\n        uint256 vaultValue = _totalValue();\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > xusdSupply)) {\n            uint256 yield = vaultValue.sub(xusdSupply);\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                xUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet XUSD supply upwards\n        xusdSupply = xUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > xusdSupply) {\n            xUSD.changeSupply(vaultValue);\n        }\n    }\n\n    /**\n     * @dev Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return value Total value in USD (1e18)\n     */\n    function totalValue() external view virtual returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return value Total value in USD (1e18)\n     */\n    function _totalValue() internal view virtual returns (uint256 value) {\n        return _totalValueInVault().add(_totalValueInStrategies());\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInVault() internal view returns (uint256 value) {\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            IERC20 asset = IERC20(allAssets[y]);\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            uint256 balance = asset.balanceOf(address(this));\n            if (balance > 0) {\n                value = value.add(balance.scaleBy(18, assetDecimals));\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return value Total value in ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            if (strategy.supportsAsset(allAssets[y])) {\n                uint256 balance = strategy.checkBalance(allAssets[y]);\n                if (balance > 0) {\n                    value = value.add(balance.scaleBy(18, assetDecimals));\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return balance Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance.add(strategy.checkBalance(_asset));\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of all assets held in Vault and all strategies.\n     * @return balance Balance of all assets (1e18)\n     */\n    function _checkBalance() internal view returns (uint256 balance) {\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n            balance = balance.add(\n                _checkBalance(allAssets[i]).scaleBy(18, assetDecimals)\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        (uint256[] memory outputs, ) = _calculateRedeemOutputs(_amount);\n        return outputs;\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return outputs Array of amounts respective to the supported assets\n     * @return totalBalance Total balance of Vault\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        returns (uint256[] memory outputs, uint256 totalBalance)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 XUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = getAssetCount();\n        uint256[] memory assetPrices = _getAssetPrices();\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        uint256[] memory assetDecimals = new uint256[](assetCount);\n        uint256 totalOutputRatio = 0;\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);\n            _amount = _amount.sub(redeemFee);\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 balance = _checkBalance(allAssets[i]);\n            uint256 decimals = Helpers.getDecimals(allAssets[i]);\n            assetBalances[i] = balance;\n            assetDecimals[i] = decimals;\n            totalBalance = totalBalance.add(balance.scaleBy(18, decimals));\n        }\n        // Calculate totalOutputRatio\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 price = assetPrices[i];\n            // Never give out more than one\n            // stablecoin per dollar of XUSD\n            if (price < 1e18) {\n                price = 1e18;\n            }\n            uint256 ratio = assetBalances[i]\n                .scaleBy(18, assetDecimals[i])\n                .mul(price)\n                .div(totalBalance);\n            totalOutputRatio = totalOutputRatio.add(ratio);\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            outputs[i] = assetBalances[i].mul(factor).div(totalBalance);\n        }\n    }\n\n    /**\n     * @notice Get an array of the supported asset prices in USD.\n     * @return assetPrices Array of asset prices in USD (1e18)\n     */\n    function _getAssetPrices()\n        internal\n        view\n        returns (uint256[] memory assetPrices)\n    {\n        assetPrices = new uint256[](getAssetCount());\n\n        IOracle oracle = IOracle(priceProvider);\n        // Price from Oracle is returned with 8 decimals\n        // _amount is in assetDecimals\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            assetPrices[i] = oracle.price(allAssets[i]).scaleBy(18, 8);\n        }\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Return the number of assets supported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @dev Return all asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @dev Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    fallback() external payable {\n        bytes32 slot = adminImplPosition;\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                sload(slot),\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IBuyback.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IBuyback {\n    function swap() external;\n}\n"
    },
    "contracts/mocks/MockRebornMinter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Sanctum {\n    address public asset;\n    address public vault;\n    address public reborner;\n    bool public shouldAttack = false;\n    uint256 public targetMethod;\n    address public xusdContract;\n\n    constructor(address _asset, address _vault) {\n        asset = _asset;\n        vault = _vault;\n    }\n\n    function deploy(uint256 salt, bytes memory bytecode)\n        public\n        returns (address addr)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, bytes memory bytecode)\n        public\n        view\n        returns (address)\n    {\n        bytes32 bytecodeHashHash = keccak256(bytecode);\n        bytes32 _data = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                bytecodeHashHash\n            )\n        );\n        return address(bytes20(_data << 96));\n    }\n\n    function setShouldAttack(bool _shouldAttack) public {\n        shouldAttack = _shouldAttack;\n    }\n\n    function setTargetMethod(uint256 target) public {\n        targetMethod = target;\n    }\n\n    function setXUSDAddress(address _xusdContract) public {\n        xusdContract = _xusdContract;\n    }\n}\n\ncontract Reborner {\n    Sanctum sanctum;\n    bool logging = false;\n\n    constructor(address _sanctum) {\n        log(\"We are created...\");\n        sanctum = Sanctum(_sanctum);\n        if (sanctum.shouldAttack()) {\n            log(\"We are attacking now...\");\n\n            uint256 target = sanctum.targetMethod();\n\n            if (target == 1) {\n                redeem();\n            } else if (target == 2) {\n                transfer();\n            } else {\n                mint();\n            }\n        }\n    }\n\n    function mint() public {\n        log(\"We are attempting to mint..\");\n        address asset = sanctum.asset();\n        address vault = sanctum.vault();\n        IERC20(asset).approve(vault, 1e18);\n        IVault(vault).mint(asset, 1e18, 0);\n        log(\"We are now minting..\");\n    }\n\n    function redeem() public {\n        log(\"We are attempting to redeem..\");\n        address vault = sanctum.vault();\n        IVault(vault).redeem(1e18, 1e18);\n        log(\"We are now redeeming..\");\n    }\n\n    function transfer() public {\n        log(\"We are attempting to transfer..\");\n        address xusd = sanctum.xusdContract();\n        require(IERC20(xusd).transfer(address(1), 1e18), \"transfer failed\");\n        log(\"We are now transfering..\");\n    }\n\n    function bye() public {\n        log(\"We are now destructing..\");\n        selfdestruct(payable(msg.sender));\n    }\n\n    function log(string memory message) internal view {\n        if (logging) {\n            console.log(message);\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/mocks/MockPangolinRouter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { IPangolinRouter } from \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\";\n\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\ncontract MockPangolinRouter is IPangolinRouter {\n    using StableMath for uint256;\n\n    address tok0;\n    address tok1;\n\n    function initialize(address _token0, address _token1) public {\n        tok0 = _token0;\n        tok1 = _token1;\n    }\n\n    function WAVAX() external pure override returns (address) {\n        return address(0);\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        require(path.length > 1, \"Path must have at least 2 addresses\");\n        require(path[0] != path[1], \"Duplicate path addresses are not allowed\");\n        // Give 1:1\n        uint256 amountOut = amountIn.scaleBy(\n            Helpers.getDecimals(tok1),\n            Helpers.getDecimals(tok0)\n        );\n        require(amountOut >= amountOutMin, \"Slippage error\");\n        IERC20(tok0).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(tok1).transfer(to, amountOut);\n    }\n\n    function factory() external pure override returns (address) {}\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {}\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (\n            uint256 amountToken,\n            uint256 amountAVAX,\n            uint256 liquidity\n        )\n    {}\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB) {}\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountToken, uint256 amountAVAX) {}\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountA, uint256 amountB) {}\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountToken, uint256 amountAVAX) {}\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {}\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {}\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {}\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {}\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {}\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure override returns (uint256 amountB) {}\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure override returns (uint256 amountOut) {}\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure override returns (uint256 amountIn) {}\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {}\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {}\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountAVAX) {}\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountAVAX) {}\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {}\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override {}\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {}\n}\n"
    },
    "contracts/mocks/MockNonRebasing.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IVault } from \"../interfaces/IVault.sol\";\n\nimport { XUSD } from \"../token/XUSD.sol\";\n\ncontract MockNonRebasing {\n    XUSD xUSD;\n\n    function setXUSD(address _xUSDAddress) public {\n        xUSD = XUSD(_xUSDAddress);\n    }\n\n    function rebaseOptIn() public {\n        xUSD.rebaseOptIn();\n    }\n\n    function rebaseOptOut() public {\n        xUSD.rebaseOptOut();\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        xUSD.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public {\n        xUSD.transferFrom(_from, _to, _value);\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue) public {\n        xUSD.increaseAllowance(_spender, _addedValue);\n    }\n\n    function mintXusd(\n        address _vaultContract,\n        address _asset,\n        uint256 _amount\n    ) public {\n        IVault(_vaultContract).mint(_asset, _amount, 0);\n    }\n\n    function redeemXusd(address _vaultContract, uint256 _amount) public {\n        IVault(_vaultContract).redeem(_amount, 0);\n    }\n\n    function approveFor(\n        address _contract,\n        address _spender,\n        uint256 _addedValue\n    ) public {\n        IERC20(_contract).approve(_spender, _addedValue);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCurvePool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\nimport { ICurvePool } from \"../../strategies/ICurvePool.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\nimport \"../../utils/Helpers.sol\";\n\ncontract MockCurvePool {\n    using StableMath for uint256;\n\n    address[] public coins;\n    uint256[2] public balances;\n    address lpToken;\n\n    constructor(address[2] memory _coins, address _lpToken) {\n        coins = _coins;\n        lpToken = _lpToken;\n    }\n\n    // Returns the same amount of LP tokens in 1e18 decimals\n    function add_liquidity(uint256[2] calldata _amounts, uint256 _minAmount)\n        external\n    {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(coins[i]).transferFrom(\n                    msg.sender,\n                    address(this),\n                    _amounts[i]\n                );\n                uint256 assetDecimals = Helpers.getDecimals(coins[i]);\n                // Convert to 1e18 and add to sum\n                sum += _amounts[i].scaleBy(18, assetDecimals);\n                balances[i] = balances[i] + _amounts[i];\n            }\n        }\n        // Hacky way of simulating slippage to check _minAmount\n        if (sum == 29000e18) sum = 14500e18;\n        require(sum >= _minAmount, \"Slippage ruined your day\");\n        // Send LP token to sender, e.g. 3CRV\n        IMintableERC20(lpToken).mint(sum);\n        IERC20(lpToken).transfer(msg.sender, sum);\n    }\n\n    // Dumb implementation that returns the same amount\n    function calc_withdraw_one_coin(uint256 _amount, int128 _index)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 assetDecimals = Helpers.getDecimals(coins[uint128(_index)]);\n        return _amount.scaleBy(assetDecimals, 18);\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _amount,\n        int128 _index,\n        uint256 _minAmount\n    ) external {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);\n        uint256[] memory amounts = new uint256[](coins.length);\n        amounts[uint128(_index)] = _amount;\n        uint256 amount = calc_withdraw_one_coin(_amount, _index);\n        IERC20(coins[uint128(_index)]).transfer(msg.sender, amount);\n        balances[uint128(_index)] = balances[uint128(_index)] - amount;\n    }\n\n    function get_virtual_price() external pure returns (uint256) {\n        return 1 * 10**18;\n    }\n\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts)\n        public\n    {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);\n        uint256 totalSupply = IERC20(lpToken).totalSupply();\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 amount = (_amount / totalSupply) *\n                IERC20(coins[i]).balanceOf(address(this));\n            IERC20(coins[i]).transfer(msg.sender, amount);\n            balances[i] = balances[i] - amount;\n        }\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[2] memory _amounts,\n        uint256 _max_burned_tokens\n    ) public {\n        IERC20(lpToken).transferFrom(\n            msg.sender,\n            address(this),\n            _max_burned_tokens\n        );\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            IERC20(coins[i]).transfer(msg.sender, _amounts[i]);\n            balances[i] = balances[i] - _amounts[i];\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\nimport { IAaveLendingPool, ILendingPoolAddressesProvider } from \"../strategies/IAave.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\n\n// 1. User calls 'getLendingPool'\n// 2. User calls 'deposit' (Aave)\n//  - Deposit their underlying\n//  - Mint aToken to them\n// 3. User calls redeem (aToken)\n//  - Retrieve their aToken\n//  - Return equal amount of underlying\n\ncontract MockAToken is MintableERC20 {\n    address public lendingPool;\n    IERC20 public underlyingToken;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lendingPool,\n        string memory _name,\n        string memory _symbol,\n        IERC20 _underlyingToken\n    ) ERC20(_name, _symbol) {\n        lendingPool = _lendingPool;\n        underlyingToken = _underlyingToken;\n        // addMinter(_lendingPool);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return ERC20(address(underlyingToken)).decimals();\n    }\n\n    function poolRedeem(uint256 _amount, address _to) external {\n        require(msg.sender == lendingPool, \"pool only\");\n        // Redeem these a Tokens\n        _burn(_to, _amount);\n        // For the underlying\n        underlyingToken.safeTransferFrom(lendingPool, _to, _amount);\n    }\n}\n\ncontract MockAave is IAaveLendingPool, ILendingPoolAddressesProvider {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    mapping(address => address) reserveToAToken;\n    address pool = address(this);\n    address payable core = payable(address(this));\n    uint256 factor;\n\n    function addAToken(address _aToken, address _underlying) public {\n        IERC20(_underlying).safeApprove(_aToken, 0);\n        IERC20(_underlying).safeApprove(_aToken, type(uint256).max);\n        reserveToAToken[_underlying] = _aToken;\n    }\n\n    // set the reserve factor / basically the interest on deposit\n    // in 18 precision\n    // so 0.5% would be 5 * 10 ^ 15\n    function setFactor(uint256 factor_) public {\n        factor = factor_;\n    }\n\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        address _to,\n        uint16 /*_referralCode*/\n    ) external override {\n        uint256 previousBal = IERC20(reserveToAToken[_reserve]).balanceOf(\n            msg.sender\n        );\n        uint256 interest = previousBal.mulTruncate(factor);\n        MintableERC20(reserveToAToken[_reserve]).mintTo(msg.sender, interest);\n        // Take their reserve\n        IERC20(_reserve).safeTransferFrom(msg.sender, address(this), _amount);\n        // Credit them with aToken\n        MintableERC20(reserveToAToken[_reserve]).mintTo(_to, _amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        MockAToken atoken = MockAToken(reserveToAToken[asset]);\n        atoken.poolRedeem(amount, to);\n        return amount;\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return pool;\n    }\n}\n"
    },
    "contracts/strategies/IAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpool\n */\ninterface IAaveLendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 avUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 avUSDC, calls withdraw() and receives 100 USDC, burning the 100 avUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\n/**\n * @dev Interface for Aaves Lending Pool\n * Documentation: https://developers.aave.com/#lendingpooladdressesprovider\n */\ninterface ILendingPoolAddressesProvider {\n    /**\n     * @notice Get the current address for Aave LendingPool\n     * @dev Lending pool is the core contract on which to call deposit\n     */\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Aave Strategy\n * @notice Investment strategy for investing stablecoins via Aave\n * @author Factor Finance\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./IAave.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\nimport { IAaveStakedToken } from \"./IAaveStakeToken.sol\";\nimport { IAaveIncentivesController } from \"./IAaveIncentivesController.sol\";\n\ncontract AaveStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    uint16 constant referralCode = 0;\n\n    IAaveIncentivesController public incentivesController;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as AAVE needs several extra\n     * addresses for the rewards program.\n     * @param _platformAddress Address of the AAVE pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddresses Addresses of the reward token(s)\n     * @param _assets Addresses of supported assets\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _incentivesAddress Address of the AAVE incentives controller\n     */\n    function initialize(\n        address _platformAddress, // AAVE pool\n        address _vaultAddress,\n        address[] calldata _rewardTokenAddresses, // [AAVE]\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _incentivesAddress\n    ) external onlyGovernor initializer {\n        incentivesController = IAaveIncentivesController(_incentivesAddress);\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit asset into Aave\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        // Following line also doubles as a check that we are depositing\n        // an asset that we support.\n        emit Deposit(_asset, _getATokenFor(_asset), _amount);\n        _getLendingPool().deposit(_asset, _amount, address(this), referralCode);\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into Aave\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            uint256 balance = IERC20(assetsMapped[i]).balanceOf(address(this));\n            if (balance > 0) {\n                _deposit(assetsMapped[i], balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Aave\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n\n        emit Withdrawal(_asset, _getATokenFor(_asset), _amount);\n        uint256 actual = _getLendingPool().withdraw(\n            _asset,\n            _amount,\n            address(this)\n        );\n        require(actual == _amount, \"Did not withdraw enough\");\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            // Redeem entire balance of aToken\n            IERC20 asset = IERC20(assetsMapped[i]);\n            address aToken = _getATokenFor(assetsMapped[i]);\n            uint256 balance = IERC20(aToken).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 actual = _getLendingPool().withdraw(\n                    address(asset),\n                    balance,\n                    address(this)\n                );\n                require(actual == balance, \"Did not withdraw enough\");\n                // Transfer entire balance to Vault\n                asset.safeTransfer(\n                    vaultAddress,\n                    asset.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Balance is always with token aToken decimals\n        address aToken = _getATokenFor(_asset);\n        balance = IERC20(aToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding aToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        address lendingPool = address(_getLendingPool());\n        // approve the pool to spend the Asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address asset = assetsMapped[i];\n            // Safe approval\n            IERC20(asset).safeApprove(lendingPool, 0);\n            IERC20(asset).safeApprove(lendingPool, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / aTokens\n            We need to give the AAVE lending pool approval to transfer the\n            asset.\n     * @param _asset Address of the asset to approve\n     * @param _aToken Address of the aToken\n     */\n    function _abstractSetPToken(address _asset, address _aToken)\n        internal\n        override\n    {\n        address lendingPool = address(_getLendingPool());\n        IERC20(_asset).safeApprove(lendingPool, 0);\n        IERC20(_asset).safeApprove(lendingPool, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the aToken wrapped in the IERC20 interface for this asset.\n     *      Fails if the pToken doesn't exist in our mappings.\n     * @param _asset Address of the asset\n     * @return Corresponding aToken to this asset\n     */\n    function _getATokenFor(address _asset) internal view returns (address) {\n        address aToken = assetToPToken[_asset];\n        require(aToken != address(0), \"aToken does not exist\");\n        return aToken;\n    }\n\n    /**\n     * @dev Get the current address of the Aave lending pool, which is the gateway to\n     *      depositing.\n     * @return Current lending pool implementation\n     */\n    function _getLendingPool() internal view returns (IAaveLendingPool) {\n        address lendingPool = ILendingPoolAddressesProvider(platformAddress)\n            .getLendingPool();\n        require(lendingPool != address(0), \"Lending pool does not exist\");\n        return IAaveLendingPool(lendingPool);\n    }\n\n    /**\n     * @dev Collect AAVE, send to Vault.\n     */\n    function collectRewardTokens() external override onlyVault nonReentrant {\n        require(\n            rewardTokenAddresses.length == 1,\n            \"Only supports single reward.\"\n        );\n        IERC20 rewardToken = IERC20(rewardTokenAddresses[0]);\n\n        address[] memory aTokens = new address[](assetsMapped.length);\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            aTokens[i] = _getATokenFor(assetsMapped[i]);\n        }\n\n        // If we have rewards availabile, collect them\n        uint256 pendingRewards = incentivesController.getRewardsBalance(\n            aTokens,\n            address(this)\n        );\n        if (pendingRewards > 0) {\n            uint256 collected = incentivesController.claimRewards(\n                aTokens,\n                pendingRewards,\n                address(this)\n            );\n            require(collected == pendingRewards, \"AAVE reward difference\");\n            rewardToken.safeTransfer(vaultAddress, collected);\n        }\n    }\n}\n"
    },
    "contracts/strategies/IAaveStakeToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IAaveStakedToken {\n    function COOLDOWN_SECONDS() external returns (uint256);\n\n    function UNSTAKE_WINDOW() external returns (uint256);\n\n    function balanceOf(address addr) external returns (uint256);\n\n    function redeem(address to, uint256 amount) external;\n\n    function stakersCooldowns(address addr) external returns (uint256);\n\n    function cooldown() external;\n}\n"
    },
    "contracts/strategies/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IAaveIncentivesController {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /*\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(\n        address[] calldata assets,\n        uint256[] calldata emissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the\n     * lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @param asset The asset to incentivize\n     * @return the user index for the asset\n     */\n    function getUserAssetData(address user, address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function PRECISION() external view returns (uint8);\n\n    /**\n     * @dev Gets the distribution end timestamp of the emissions\n     */\n    function DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/proxies/InitializeGovernedUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { Governable } from \"../governance/Governable.sol\";\n\n/**\n * @title BaseGovernedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with our governor system.\n * It is based on an older version of OpenZeppelins BaseUpgradeabilityProxy\n * with Solidity ^0.8.0.\n * @author Factor Finance\n */\ncontract InitializeGovernedUpgradeabilityProxy is Governable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Contract initializer with Governor enforcement\n     * @param _logic Address of the initial implementation.\n     * @param _initGovernor Address of the initial Governor.\n     * @param _data Data to send as msg.data to the implementation to initialize\n     * the proxied contract.\n     * It should include the signature and the parameters of the function to be\n     * called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call\n     * to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _initGovernor,\n        bytes memory _data\n    ) public payable onlyGovernor {\n        require(_implementation() == address(0));\n        assert(\n            IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        _changeGovernor(_initGovernor);\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n\n    /**\n     * @return The address of the proxy admin/it's also the governor.\n     */\n    function admin() external view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external onlyGovernor {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyGovernor\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param _impl Address to delegate.\n     */\n    function _delegate(address _impl) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Cannot set a proxy implementation to a non-contract address\"\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/proxies/Proxies.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { InitializeGovernedUpgradeabilityProxy } from \"./InitializeGovernedUpgradeabilityProxy.sol\";\n\n/**\n * @notice XUSDProxy delegates calls to an XUSD implementation\n */\ncontract XUSDProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice VaultProxy delegates calls to a Vault implementation\n */\ncontract VaultProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract AaveStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AlphaHomoraStrategyProxy delegates calls to a AlphaHomoraStrategy implementation\n */\ncontract AlphaHomoraStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n\n/**\n * @notice AaveStrategyProxy delegates calls to a AaveStrategy implementation\n */\ncontract CurveUsdcStrategyProxy is InitializeGovernedUpgradeabilityProxy {\n\n}\n"
    },
    "contracts/oracle/MixOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n// DEPRECATED - This contract is no longer used in production\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD MixOracle Contract\n * @notice The MixOracle pulls exchange rate from multiple oracles and returns\n *         min and max values.\n * @author Factor Finance\n */\nimport { IPriceOracle } from \"../interfaces/IPriceOracle.sol\";\nimport { IEthUsdOracle } from \"../interfaces/IEthUsdOracle.sol\";\nimport { IMinMaxOracle } from \"../interfaces/IMinMaxOracle.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\ncontract MixOracle is IMinMaxOracle, Governable {\n    event DriftsUpdated(uint256 _minDrift, uint256 _maxDrift);\n    event EthUsdOracleRegistered(address _oracle);\n    event EthUsdOracleDeregistered(address _oracle);\n    event TokenOracleRegistered(\n        string symbol,\n        address[] ethOracles,\n        address[] usdOracles\n    );\n\n    address[] public ethUsdOracles;\n\n    struct MixConfig {\n        address[] usdOracles;\n        address[] ethOracles;\n    }\n\n    mapping(bytes32 => MixConfig) configs;\n\n    uint256 constant MAX_INT = 2**256 - 1;\n    uint256 public maxDrift;\n    uint256 public minDrift;\n\n    constructor(uint256 _maxDrift, uint256 _minDrift) {\n        maxDrift = _maxDrift;\n        minDrift = _minDrift;\n        emit DriftsUpdated(_minDrift, _maxDrift);\n    }\n\n    function setMinMaxDrift(uint256 _minDrift, uint256 _maxDrift)\n        public\n        onlyGovernor\n    {\n        minDrift = _minDrift;\n        maxDrift = _maxDrift;\n        emit DriftsUpdated(_minDrift, _maxDrift);\n    }\n\n    /**\n     * @notice Adds an oracle to the list of oracles to pull data from.\n     * @param oracle Address of an oracle that implements the IEthUsdOracle interface.\n     **/\n    function registerEthUsdOracle(address oracle) public onlyGovernor {\n        for (uint256 i = 0; i < ethUsdOracles.length; i++) {\n            require(ethUsdOracles[i] != oracle, \"Oracle already registered.\");\n        }\n        ethUsdOracles.push(oracle);\n        emit EthUsdOracleRegistered(oracle);\n    }\n\n    /**\n     * @notice Removes an oracle to the list of oracles to pull data from.\n     * @param oracle Address of an oracle that implements the IEthUsdOracle interface.\n     **/\n    function unregisterEthUsdOracle(address oracle) public onlyGovernor {\n        for (uint256 i = 0; i < ethUsdOracles.length; i++) {\n            if (ethUsdOracles[i] == oracle) {\n                // swap with the last element of the array, and then delete last element (could be itself)\n                ethUsdOracles[i] = ethUsdOracles[ethUsdOracles.length - 1];\n                delete ethUsdOracles[ethUsdOracles.length - 1];\n                emit EthUsdOracleDeregistered(oracle);\n                ethUsdOracles.pop();\n                return;\n            }\n        }\n        revert(\"Oracle not found\");\n    }\n\n    /**\n     * @notice Adds an oracle to the list of oracles to pull data from.\n     * @param ethOracles Addresses of oracles that implements the IEthUsdOracle interface and answers for this asset\n     * @param usdOracles Addresses of oracles that implements the IPriceOracle interface and answers for this asset\n     **/\n    function registerTokenOracles(\n        string calldata symbol,\n        address[] calldata ethOracles,\n        address[] calldata usdOracles\n    ) external onlyGovernor {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        config.ethOracles = ethOracles;\n        config.usdOracles = usdOracles;\n        emit TokenOracleRegistered(symbol, ethOracles, usdOracles);\n    }\n\n    /**\n     * @notice Returns the min price of an asset in USD.\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @return price Min price from all the oracles, in USD with 8 decimal digits.\n     **/\n    function priceMin(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        uint256 ep;\n        uint256 p; //holder variables\n        price = MAX_INT;\n        if (config.ethOracles.length > 0) {\n            ep = MAX_INT;\n            for (uint256 i = 0; i < config.ethOracles.length; i++) {\n                p = IEthUsdOracle(config.ethOracles[i]).tokEthPrice(symbol);\n                if (ep > p) {\n                    ep = p;\n                }\n            }\n            price = ep;\n            ep = MAX_INT;\n            for (uint256 i = 0; i < ethUsdOracles.length; i++) {\n                p = IEthUsdOracle(ethUsdOracles[i]).ethUsdPrice();\n                if (ep > p) {\n                    ep = p;\n                }\n            }\n            if (price != MAX_INT && ep != MAX_INT) {\n                // tokEthPrice has precision of 8 which ethUsdPrice has precision of 6\n                // we want precision of 8\n                price = (price * ep) / 1e6;\n            }\n        }\n\n        if (config.usdOracles.length > 0) {\n            for (uint256 i = 0; i < config.usdOracles.length; i++) {\n                // upscale by 2 since price oracles are precision 6\n                p = IPriceOracle(config.usdOracles[i]).price(symbol) * 1e2;\n                if (price > p) {\n                    price = p;\n                }\n            }\n        }\n        require(price <= maxDrift, \"Price exceeds maxDrift\");\n        require(price >= minDrift, \"Price below minDrift\");\n        require(\n            price != MAX_INT,\n            \"None of our oracles returned a valid min price!\"\n        );\n    }\n\n    /**\n     * @notice Returns max price of an asset in USD.\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @return price Max price from all the oracles, in USD with 8 decimal digits.\n     **/\n    function priceMax(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256 price)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        uint256 ep;\n        uint256 p; //holder variables\n        price = 0;\n        if (config.ethOracles.length > 0) {\n            ep = 0;\n            for (uint256 i = 0; i < config.ethOracles.length; i++) {\n                p = IEthUsdOracle(config.ethOracles[i]).tokEthPrice(symbol);\n                if (ep < p) {\n                    ep = p;\n                }\n            }\n            price = ep;\n            ep = 0;\n            for (uint256 i = 0; i < ethUsdOracles.length; i++) {\n                p = IEthUsdOracle(ethUsdOracles[i]).ethUsdPrice();\n                if (ep < p) {\n                    ep = p;\n                }\n            }\n            if (price != 0 && ep != 0) {\n                // tokEthPrice has precision of 8 which ethUsdPrice has precision of 6\n                // we want precision of 8\n                price = (price * ep) / 1e6;\n            }\n        }\n\n        if (config.usdOracles.length > 0) {\n            for (uint256 i = 0; i < config.usdOracles.length; i++) {\n                // upscale by 2 since price oracles are precision 6\n                p = IPriceOracle(config.usdOracles[i]).price(symbol) * 1e2;\n                if (price < p) {\n                    price = p;\n                }\n            }\n        }\n\n        require(price <= maxDrift, \"Price exceeds maxDrift\");\n        require(price >= minDrift, \"Price below minDrift\");\n        require(price != 0, \"None of our oracles returned a valid max price!\");\n    }\n\n    /**\n     * @notice Returns the length of the usdOracles array for a given token\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @return length of the USD oracles array\n     **/\n    function getTokenUSDOraclesLength(string calldata symbol)\n        external\n        view\n        returns (uint256)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        return config.usdOracles.length;\n    }\n\n    /**\n     * @notice Returns the address of a specific USD oracle\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @param idx Index of the array value to return\n     * @return address of the oracle\n     **/\n    function getTokenUSDOracle(string calldata symbol, uint256 idx)\n        external\n        view\n        returns (address)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        return config.usdOracles[idx];\n    }\n\n    /**\n     * @notice Returns the length of the ethOracles array for a given token\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @return length of the ETH oracles array\n     **/\n    function getTokenETHOraclesLength(string calldata symbol)\n        external\n        view\n        returns (uint256)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        return config.ethOracles.length;\n    }\n\n    /**\n     * @notice Returns the address of a specific ETH oracle\n     * @param symbol Asset symbol. Example: \"DAI\"\n     * @param idx Index of the array value to return\n     * @return address of the oracle\n     **/\n    function getTokenETHOracle(string calldata symbol, uint256 idx)\n        external\n        view\n        returns (address)\n    {\n        MixConfig storage config = configs[keccak256(abi.encodePacked(symbol))];\n        return config.ethOracles[idx];\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IEthUsdOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\ninterface IViewEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IMinMaxOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IMinMaxOracle {\n    //Assuming 8 decimals\n    function priceMin(string calldata symbol) external view returns (uint256);\n\n    function priceMax(string calldata symbol) external view returns (uint256);\n}\n"
    },
    "contracts/mocks/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/IMinMaxOracle.sol\";\n\n/**\n * Mock of both price Oracle and min max oracles\n */\ncontract MockOracle is IPriceOracle, IMinMaxOracle {\n    mapping(bytes32 => uint256) prices;\n    mapping(bytes32 => uint256[]) pricesMinMax;\n    uint256 ethMin;\n    uint256 ethMax;\n\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return prices[keccak256(abi.encodePacked(symbol))];\n    }\n\n    /**\n     * @dev sets the price of the asset in USD, 6 decimal digits\n     *\n     */\n    function setPrice(string calldata symbol, uint256 _price) external {\n        prices[keccak256(abi.encodePacked(symbol))] = _price;\n    }\n\n    /**\n     * @dev sets the min and max price of ETH in USD, 6 decimal digits\n     *\n     */\n    function setEthPriceMinMax(uint256 _min, uint256 _max) external {\n        ethMin = _min;\n        ethMax = _max;\n    }\n\n    /**\n     * @dev sets the prices Min Max for a specific symbol in ETH, 8 decimal digits\n     *\n     */\n    function setTokPriceMinMax(\n        string calldata symbol,\n        uint256 _min,\n        uint256 _max\n    ) external {\n        pricesMinMax[keccak256(abi.encodePacked(symbol))] = [_min, _max];\n    }\n\n    /**\n     * @dev get the price of asset in ETH, 8 decimal digits.\n     */\n    function priceMin(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[0] * ethMin) / 1e6;\n    }\n\n    /**\n     * @dev get the price of asset in USD, 8 decimal digits.\n     * Not needed for now\n     */\n    function priceMax(string calldata symbol)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256[] storage pMinMax = pricesMinMax[\n            keccak256(abi.encodePacked(symbol))\n        ];\n        return (pMinMax[1] * ethMax) / 1e6;\n    }\n}\n"
    },
    "contracts/governance/InitializableGovernable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD InitializableGovernable Contract\n * @author Factor Finance\n */\nimport { Initializable } from \"../utils/Initializable.sol\";\n\nimport { Governable } from \"./Governable.sol\";\n\ncontract InitializableGovernable is Governable, Initializable {\n    function _initialize(address _newGovernor) internal {\n        _changeGovernor(_newGovernor);\n    }\n}\n"
    },
    "contracts/flipper/Flipper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../governance/Governable.sol\";\nimport \"../token/XUSD.sol\";\nimport \"../interfaces/Tether.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contract to exchange usdt, usdc, dai from and to xusd.\n//   - 1 to 1. No slippage\n//   - Optimized for low gas usage\n//   - No guarantee of availability\n\ncontract Flipper is Governable {\n    using SafeERC20 for IERC20;\n\n    uint256 constant MAXIMUM_PER_TRADE = (25000 * 1e18);\n\n    // Settable coin addresses allow easy testing and use of mock currencies.\n    IERC20 immutable dai;\n    XUSD immutable xusd;\n    IERC20 immutable usdc;\n    Tether immutable usdt;\n\n    // ---------------------\n    // Dev constructor\n    // ---------------------\n    constructor(\n        address _dai,\n        address _xusd,\n        address _usdc,\n        address _usdt\n    ) {\n        require(address(_dai) != address(0));\n        require(address(_xusd) != address(0));\n        require(address(_usdc) != address(0));\n        require(address(_usdt) != address(0));\n        dai = IERC20(_dai);\n        xusd = XUSD(_xusd);\n        usdc = IERC20(_usdc);\n        usdt = Tether(_usdt);\n    }\n\n    // -----------------\n    // Trading functions\n    // -----------------\n\n    /// @notice Purchase XUSD with Dai\n    /// @param amount Amount of XUSD to purchase, in 18 fixed decimals.\n    function buyXusdWithDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(\n            dai.transferFrom(msg.sender, address(this), amount),\n            \"DAI transfer failed\"\n        );\n        require(xusd.transfer(msg.sender, amount), \"XUSD transfer failed\");\n    }\n\n    /// @notice Sell XUSD for Dai\n    /// @param amount Amount of XUSD to sell, in 18 fixed decimals.\n    function sellXusdForDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transfer(msg.sender, amount), \"DAI transfer failed\");\n        require(\n            xusd.transferFrom(msg.sender, address(this), amount),\n            \"XUSD transfer failed\"\n        );\n    }\n\n    /// @notice Purchase XUSD with USDC\n    /// @param amount Amount of XUSD to purchase, in 18 fixed decimals.\n    function buyXusdWithUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional trade off\n        require(\n            usdc.transferFrom(msg.sender, address(this), amount / 1e12),\n            \"USDC transfer failed\"\n        );\n        require(xusd.transfer(msg.sender, amount), \"XUSD transfer failed\");\n    }\n\n    /// @notice Sell XUSD for USDC\n    /// @param amount Amount of XUSD to sell, in 18 fixed decimals.\n    function sellXusdForUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(\n            usdc.transfer(msg.sender, amount / 1e12),\n            \"USDC transfer failed\"\n        );\n        require(\n            xusd.transferFrom(msg.sender, address(this), amount),\n            \"XUSD transfer failed\"\n        );\n    }\n\n    /// @notice Purchase XUSD with USDT\n    /// @param amount Amount of XUSD to purchase, in 18 fixed decimals.\n    function buyXusdWithUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional trade off\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transferFrom(msg.sender, address(this), amount / 1e12);\n        require(xusd.transfer(msg.sender, amount), \"XUSD transfer failed\");\n    }\n\n    /// @notice Sell XUSD for USDT\n    /// @param amount Amount of XUSD to sell, in 18 fixed decimals.\n    function sellXusdForUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transfer(msg.sender, amount / 1e12);\n        require(\n            xusd.transferFrom(msg.sender, address(this), amount),\n            \"XUSD transfer failed\"\n        );\n    }\n\n    // --------------------\n    // Governance functions\n    // --------------------\n\n    /// @dev Opting into yield reduces the gas cost per transfer by about 4K, since\n    /// xusd needs to do less accounting and one less storage write.\n    function rebaseOptIn() external onlyGovernor nonReentrant {\n        xusd.rebaseOptIn();\n    }\n\n    /// @notice Owner function to withdraw a specific amount of a token\n    function withdraw(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n\n    /// @notice Owner function to withdraw all tradable tokens\n    /// @dev Contract will not perform any swaps until liquidity is provided\n    /// again by transferring assets to the contract.\n    function withdrawAll() external onlyGovernor nonReentrant {\n        IERC20(dai).safeTransfer(_governor(), dai.balanceOf(address(this)));\n        IERC20(xusd).safeTransfer(_governor(), xusd.balanceOf(address(this)));\n        IERC20(address(usdt)).safeTransfer(\n            _governor(),\n            usdt.balanceOf(address(this))\n        );\n        IERC20(usdc).safeTransfer(_governor(), usdc.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/interfaces/Tether.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface Tether {\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    function balanceOf(address) external returns (uint256);\n}\n"
    },
    "contracts/mocks/curve/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ICurveGauge } from \"../../strategies/ICurveGauge.sol\";\nimport { MockWAVAX } from \"../MockWAVAX.sol\";\nimport { IMintableERC20 } from \"../MintableERC20.sol\";\n\ncontract MockCurveGauge is ICurveGauge {\n    mapping(address => uint256) private _balances;\n    address lpToken;\n    address[] reward_tokens;\n    uint256 amount;\n\n    constructor(address _lpToken) {\n        lpToken = _lpToken;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function deposit(uint256 _value, address _account) external override {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), _value);\n        _balances[_account] += _value;\n    }\n\n    function withdraw(uint256 _value) external override {\n        IERC20(lpToken).transfer(msg.sender, _value);\n        _balances[msg.sender] -= _value;\n    }\n\n    function addRewardToken(address rewardAddress) external {\n        // mock only method for testing\n        reward_tokens.push(rewardAddress);\n    }\n\n    function setRewardAmount(uint256 _amount) external {\n        amount = _amount;\n    }\n\n    function claim_rewards(address _sender, address _receiver)\n        external\n        override\n    {\n        address reward = reward_tokens[0];\n        if (amount > 0) {\n            // TODO: loop over multiple rewards\n            IMintableERC20(reward).mint(amount);\n            IERC20(reward).transfer(_receiver, amount);\n            amount = 0;\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockWAVAX.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockWAVAX is MintableERC20 {\n    constructor() ERC20(\"WAVAX\", \"WAVAX\") {}\n}\n"
    },
    "contracts/mocks/BurnableERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IBurnableERC20 {\n    function burn(uint256 value) external returns (bool);\n\n    function burnFrom(address account, uint256 value) external returns (bool);\n}\n\n/**\n * @title BurnableERC20\n * @dev Exposes the burn function of ERC20 for tests\n */\nabstract contract BurnableERC20 is IBurnableERC20, ERC20 {\n    /**\n     * @dev Function to burn tokens\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burn(uint256 value) public virtual override returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    /**\n     * @dev Function to burn tokens from a specific account\n     * @param account The address with the tokens to burn.\n     * @param value The amount of tokens to burn.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function burnFrom(address account, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        _burn(account, value);\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockEvilDAI.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract MockEvilDAI is MintableERC20 {\n    address host;\n    address realCoin;\n\n    constructor(address _host, address _realCoin) ERC20(\"DAI\", \"DAI\") {\n        host = _host;\n        realCoin = _realCoin;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public override returns (bool) {\n        // call mint again!\n        if (_amount != 69) {\n            IVault(host).mint(address(this), 69, 0);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/MockVault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { VaultCore } from \"../vault/VaultCore.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { VaultInitializer } from \"../vault/VaultInitializer.sol\";\nimport \"../utils/Helpers.sol\";\n\ncontract MockVault is VaultCore, VaultInitializer {\n    using StableMath for uint256;\n\n    uint256 storedTotalValue;\n\n    function setTotalValue(uint256 _value) public {\n        storedTotalValue = _value;\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _totalValue() internal view override returns (uint256) {\n        return storedTotalValue;\n    }\n\n    function _checkBalance(address _asset)\n        internal\n        view\n        override\n        returns (uint256 balance)\n    {\n        // Avoids rounding errors by returning the total value\n        // in a single currency\n        if (allAssets[0] == _asset) {\n            uint256 decimals = Helpers.getDecimals(_asset);\n            return storedTotalValue.scaleBy(decimals, 18);\n        } else {\n            return 0;\n        }\n    }\n\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n    }\n}\n"
    },
    "contracts/vault/VaultInitializer.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD VaultInitializer Contract\n * @notice The Vault contract initializes the vault.\n * @author Factor Finance\n */\n\nimport \"./VaultStorage.sol\";\n\ncontract VaultInitializer is VaultStorage {\n    function initialize(address _priceProvider, address _xusd)\n        external\n        onlyGovernor\n        initializer\n    {\n        require(_priceProvider != address(0), \"PriceProvider address is zero\");\n        require(_xusd != address(0), \"xUSD address is zero\");\n\n        xUSD = XUSD(_xusd);\n\n        priceProvider = _priceProvider;\n\n        rebasePaused = false;\n        capitalPaused = true;\n\n        // Initial redeem fee of 0 basis points\n        redeemFeeBps = 0;\n        // Initial Vault buffer of 0%\n        vaultBuffer = 0;\n        // Initial allocate threshold of 25,000 XUSD\n        autoAllocateThreshold = 25000e18;\n        // Threshold for rebasing\n        rebaseThreshold = 1000e18;\n    }\n}\n"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD VaultInitializer Contract\n * @notice The VaultInitializer sets up the initial contract.\n * @author Factor Finance\n */\nimport { VaultInitializer } from \"./VaultInitializer.sol\";\nimport { VaultAdmin } from \"./VaultAdmin.sol\";\n\ncontract Vault is VaultInitializer, VaultAdmin {}\n"
    },
    "contracts/timelock/Timelock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title XUSD Timelock Contract\n * @author Factor Finance\n */\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface CapitalPausable {\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n}\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 3 days;\n    uint256 public constant MINIMUM_DELAY = 1 minutes;\n    uint256 public constant MAXIMUM_DELAY = 2 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    /**\n     * @dev Throws if called by any account other than the Admin.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Caller is not the admin\");\n        _;\n    }\n\n    constructor(address admin_, uint256 delay_) {\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setDelay: Call must come from Timelock.\"\n        );\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public onlyAdmin {\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"Timelock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            msg.sender == admin,\n            \"Timelock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, signature, data, eta);\n    }\n\n    function _getRevertMsg(bytes memory _returnData)\n        internal\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed\n        // silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string));\n    }\n\n    function executeTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"Timelock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        require(\n            queuedTransactions[txHash],\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n            \"Timelock::executeTransaction: Transaction is stale.\"\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(\n                bytes4(keccak256(bytes(signature))),\n                data\n            );\n        }\n\n        (bool success, bytes memory returnData) = target.call(callData);\n\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n\n        emit ExecuteTransaction(txHash, target, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    function pauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::pauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).pauseCapital();\n    }\n\n    function unpauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::unpauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).unpauseCapital();\n    }\n}\n"
    },
    "contracts/governance/Governor.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./../timelock/Timelock.sol\";\n\n// Modeled off of Compound's Governor Alpha\n//    https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\ncontract Governor is Timelock {\n    // @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // @notice Unique id for looking up a proposal\n        uint256 id;\n        // @notice Creator of the proposal\n        address proposer;\n        // @notice The timestamp that the proposal will be available for\n        // execution, set once the vote succeeds\n        uint256 eta;\n        // @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        // @notice The ordered list of function signatures to be called\n        string[] signatures;\n        // @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // @notice Flag marking whether the proposal has been executed\n        bool executed;\n    }\n\n    // @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        string[] signatures,\n        bytes[] calldatas,\n        string description\n    );\n\n    // @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // @notice An event emitted when a proposal has been cancelled\n    event ProposalCancelled(uint256 id);\n\n    uint256 public constant MAX_OPERATIONS = 32;\n\n    // @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    constructor(address admin_, uint256 delay_) Timelock(admin_, delay_) {}\n\n    /**\n     * @notice Propose Governance call(s)\n     * @param targets Ordered list of targeted addresses\n     * @param signatures Orderd list of function signatures to be called\n     * @param calldatas Orderded list of calldata to be passed with each call\n     * @param description Description of the governance\n     * @return uint256 id of the proposal\n     */\n    function propose(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow anyone to propose for now, since only admin can queue the\n        // transaction it should be harmless, you just need to pay the gas\n        require(\n            targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"Governor::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\n        require(\n            targets.length <= MAX_OPERATIONS,\n            \"Governor::propose: too many actions\"\n        );\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            signatures: signatures,\n            calldatas: calldatas,\n            executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            signatures,\n            calldatas,\n            description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queue a proposal for execution\n     * @param proposalId id of the proposal to queue\n     */\n    function queue(uint256 proposalId) public onlyAdmin {\n        require(\n            state(proposalId) == ProposalState.Pending,\n            \"Governor::queue: proposal can only be queued if it is pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = block.timestamp + delay;\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalQueued(proposal.id, proposal.eta);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId id of the proposal\n     * @return ProposalState\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"Governor::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Pending;\n        } else if (block.timestamp >= proposal.eta + GRACE_PERIOD) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function _queueOrRevert(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !queuedTransactions[\n                keccak256(abi.encode(target, signature, keccak256(data), eta))\n            ],\n            \"Governor::_queueOrRevert: proposal action already queued at eta\"\n        );\n        require(\n            queuedTransactions[queueTransaction(target, signature, data, eta)],\n            \"Governor::_queueOrRevert: failed to queue transaction\"\n        );\n    }\n\n    /**\n     * @notice Execute a proposal.\n     * @param proposalId id of the proposal\n     */\n    function execute(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"Governor::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            executeTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancel a proposal.\n     * @param proposalId id of the proposal\n     */\n    function cancel(uint256 proposalId) public onlyAdmin {\n        ProposalState proposalState = state(proposalId);\n\n        require(\n            proposalState == ProposalState.Queued ||\n                proposalState == ProposalState.Pending,\n            \"Governor::execute: proposal can only be cancelled if it is queued or pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = 1; // To mark the proposal as `Expired`\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            cancelTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalCancelled(proposalId);\n    }\n\n    /**\n     * @notice Get the actions that a proposal will take.\n     * @param proposalId id of the proposal\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.signatures, p.calldatas);\n    }\n}\n"
    },
    "contracts/mocks/MockDAI.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockDAI is MintableERC20 {\n    constructor() ERC20(\"DAI\", \"DAI\") {}\n}\n"
    },
    "contracts/mocks/MockALPHAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockALPHA is MintableERC20 {\n    constructor() ERC20(\"ALPHA\", \"ALPHA\") {}\n}\n"
    },
    "contracts/mocks/MockAlphaIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\n\ncontract MockAlphaIncentivesController {\n    mapping(address => uint256) private rewards;\n    address private vaultAddress;\n    mapping(address => uint256) public claimed;\n    address public token;\n    MintableERC20 public REWARD_TOKEN;\n\n    constructor(address _reward_token) {\n        token = _reward_token;\n        REWARD_TOKEN = MintableERC20(token);\n    }\n\n    function setVault(address _vaultAddress) external {\n        vaultAddress = _vaultAddress;\n    }\n\n    function setRewardBalance(address user, uint256 amount) external {\n        rewards[user] = amount;\n    }\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardBalance(address user) external view returns (uint256) {\n        return rewards[user];\n    }\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claim(\n        address to,\n        uint256 amount,\n        bytes32[] calldata proof\n    ) external returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        require(rewards[to] == amount);\n        require(proof.length > 0);\n        require(vaultAddress != address(0));\n        REWARD_TOKEN.mint(amount);\n        require(REWARD_TOKEN.transfer(vaultAddress, amount));\n        rewards[to] = 0;\n        claimed[to] = claimed[to] + amount;\n        return amount;\n    }\n}\n"
    },
    "contracts/mocks/MockAAVEToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./MintableERC20.sol\";\n\ncontract MockAAVEToken is MintableERC20 {\n    constructor() ERC20(\"AAVE\", \"AAVE\") {}\n}\n"
    },
    "contracts/mocks/MockAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport { MintableERC20 } from \"./MintableERC20.sol\";\n\ncontract MockAaveIncentivesController {\n    mapping(address => uint256) private rewards;\n    MintableERC20 public REWARD_TOKEN;\n\n    constructor(address _reward_token) {\n        REWARD_TOKEN = MintableERC20(_reward_token);\n    }\n\n    function setRewardsBalance(address user, uint256 amount) external {\n        rewards[user] = amount;\n    }\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256)\n    {\n        return rewards[user];\n    }\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        require(rewards[to] == amount);\n        REWARD_TOKEN.mint(amount);\n        require(REWARD_TOKEN.transfer(to, amount));\n        rewards[to] = 0;\n        return amount;\n    }\n}\n"
    },
    "contracts/mocks/curve/MockUsdcPair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockUsdcPair is MintableERC20 {\n    constructor()\n        ERC20(\"Curve.fi Factory Plain Pool: USD Coin\", \"USDC.eUSDC-f\")\n    {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    function burnFrom(address from, uint256 value) public {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/mocks/curve/MockCRV.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../MintableERC20.sol\";\n\ncontract MockCRV is MintableERC20 {\n    constructor() ERC20(\"Curve DAO Token\", \"CRV\") {}\n\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/mocks/MockChainlinkOracleFeed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkOracleFeed is AggregatorV3Interface {\n    int256 price;\n    uint8 numDecimals;\n\n    constructor(int256 _price, uint8 _decimals) {\n        price = _price;\n        numDecimals = _decimals;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return numDecimals;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"MockOracleEthFeed\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function setPrice(int256 _price) public {\n        price = _price;\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        numDecimals = _decimals;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _roundId;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = 0;\n        answer = price;\n        startedAt = 0;\n        updatedAt = 0;\n        answeredInRound = 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}